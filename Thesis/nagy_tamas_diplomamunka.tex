\documentclass[a4paper,12pt]{report}


\usepackage[latin2]{inputenc} % vagy latin2 helyett utf8
\usepackage[T1]{fontenc}      % karakterkódolás
\usepackage[magyar]{babel}    % magyar beállítások
\frenchspacing                % helyközök
%\usepackage{times}           % betûtípus
\usepackage{lmodern}          %   vagy inkább ez

\usepackage[margin=2.5cm,left=3.5cm,includeheadfoot]{geometry}
                              % margók
\usepackage{graphicx}         % képekhez
\usepackage{grffile}
\usepackage{setspace}         % sorköz
\onehalfspacing               % másfeles

\usepackage{hyperref}		  % table of contents hyperlink
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\usepackage{amsmath}
\usepackage{caption}

\usepackage{chngcntr}
\usepackage{siunitx}
\usepackage{float}

%\usepackage[nottoc,numbib]{tocbibind}

\counterwithout{figure}{chapter}

\graphicspath {{figures/}}




\begin{document}

% ------------------------------------------------------------------------------
% Címlap

\input{cimlap.tex}

% ------------------------------------------------------------------------------
% Témabejelentõ

%\vspace*{\fill}

%\vfill
%\thispagestyle{empty}
%\newpage
%\setcounter{page}{1}

% ------------------------------------------------------------------------------
% Tartalomjegyzék

%TODO Fix Bibliography
\tableofcontents

% ------------------------------------------------------------------------------


\chapter{Bevezetés}
Lorem ipsum...


% ------------------------------------------------------------------------------

\chapter{Távérzékelt felvételek elemzése} \label{ch:remoteSensingAnalysis}
A fejezet célja betekintést nyújtani távérzékelt felvételkiértékelés folyamatába.
Elsõként a távérzékelés fogalma, fizikai és technikai alapjai, valamint alkalmazási lehetõségei kerülnek ismertetésre.
Ezután a távérzékelt felvételek kiértékelésének célja, feldolgozási folyamata
és a folyamat során elvégzett mûveletek bemutatása következik.

\section{A Távérzékelés}
Távérzékelés alatt olyan adatgyûjtési és feldolgozási eljárásokat értünk, melynek során
tárgyakról vagy területekrõl közvetve, azok érintése nélkül gyûjtünk és rögzítünk adatokat.

Manapság a távérzékelést leggyakrabban földfelszíni-, illetve légköri adatok begyûjtésére értjük, valamilyen légi, vagy ûrbéli szenzor segítségével. 
Ezek a szenzorok a földfelszínrõl érkezõ energiát érzékelik, ez által alkotnak képet egy bizonyos területrõl. \cite{richards}

\subsection{A távérzékelés fizikai és technikai alapjai}
A távérzékelõ rendszereknek alapvetõen három fõ összetevõje van: A sugárforrás, a megfigyelés tárgyát képezõ földfelszín és az érzékelõ.

Az érzékelt energia forrása alapján beszélhetünk \textit{passzív}-, illetve \textit{aktív }távérzékelõ szenzorokról.
A \textit{passzív} szenzorok valamilyen természetes energia sugárzását érzékelik, ez lehet a Föld által kibocsátott, vagy
visszavert energia. \textit{Passzív} szenzorok által leggyakrabban használt energiaforrás a Napból érkezõ visszavert energia.
Az \textit{aktív} szenzorok abban különböznek passzív társaiktól, hogy õk maguk sugározzák a földfelszínre az érzékelni kívánt energiát.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=90mm]{figures/remote_sensing_components.jpg}
	\caption{A távérzékelési rendszer összetevõi \label{remote_sensing_components}}
\end{figure}

A távérzékelt felvételek \textit{spektrális felbontás}a meghatározza, hogy az elektromágneses spektrumon belül mely
hullámsávokat milyen részletességgel vételezi a szenzor. Az úgynevezett \textit{pankromatikus} szenzorok egy spektrális
sávot felvételeznek, mely lefedi a teljes látható tartományt, valamint belenyúlhat a közeli infravörös tartományba.
A \textit{multispektrális} szenzorok több különbözõ elektromágneses hullámsávban érzékelnek. A leggyakrabban használt
\textit{multispektrális} szenzorok sávszáma 3 és 7 között van, és a reflektív tartomány mellett 
a termális infravörös sávot is felvételezik.

Az érzékelõ a megadott hullámsávban beérkezõ mennyiséget digitális értékekké alakítja - az érzékelõk \textit{radiometriai felbontása} 
a kvantálás finomságát jelzi. Minél több energiaszintet képes megkülönböztetni az szenzor, annál magasabb
radiometriai felbontással rendelkezik. A legelterjedtebb nagyfelbontású multispektrális szenzoroknál 
a 7-8 bites felbontás jellemzõ, mely 128, illetve 256 különbözõ intenzitásszintnek felel meg.

Egy többsávos digitális felvételezés eredménye egy olyan mátrixként értelmezhetõ, melynek minden eleme egy elemi
felszíndarabnak felel meg - a mátrix elemeinek pozíciója kapcsolatban van a felvételezett felszíndarab földrajzi
helyzetével. Az egyes mátrixértékek maguk is vektorok, melyek elemei a megadott felszíndarabon belül az egyes
spektrális sávokban mért intenzitásértékeket tartalmazzák. Egy \textit{N} sorból és \textit{M} oszlopból álló
többsávos digitális felvétel az alábbi formulában írható le:

\begin{center}
$
V = 
\begin{pmatrix}
\vec{v}_{1,1} & \cdots & \vec{v}_{1,\textit{M}} \\
\vdots  & \ddots & \vdots  \\
\vec{v}_{\textit{N},1} & \cdots & \vec{v}_{\textit{N,M}} 
\end{pmatrix}
$,
\end{center}

ahol B számú spektrális sávot feltételezve $\vec{v}_{\textit{i,j}} = (v_{\textit{i,j}1}, \hdots, v_{\textit{i,jB}})$
az egyes elemekhez tartozó intenzitásértékek vektora. A mátrix elemeinek koordinátáit és értékeit annak megfelelõen értelmezzük,
amelyet az elvégezni kívánt mûvelet megkövetel. \cite{remoteSensingLecture}

\subsection{Távérzékelt felvételek alkalmazási területei}
Az élet számos területén felhasználhatóak a távérzékeléssel nyert információk, például:
\begin{itemize}
	\item \textbf{Katasztrófavédelem} 
	\newline 
	Hurrikánok, földrengések, erózió, árvíz megfigyelése. A távérzékelt adatokat felhasználhatjuk a
	természeti katasztrófa hatásainak kiértékelésére, az információ alapján megelõzõ lépéseket tehetünk a jelenlegi helyzet kezelésére, valamint a jövõbeni katasztrófákra is felkészülhetünk.
	
	\item \textbf{Természeti erõforrások monitorozása }
	\newline
	Földhasználat, vadvilági területek monitorozása. A távérzékelt adatok felhasználásával minimalizálhatjuk a
	városi növekedés káros hatásait a környezetre, valamint dönthetünk, hogyan védhetjük természeti erõforrásainkat.

	\item \textbf{Mezõgazdasági termés,- illetve hozambecslés }
	\newline
	A távérzékelt adatok segítségével becslést adhatunk a monitorozott termõterület hozamára, illetve megelõzhetjük
	a termést veszélyeztetõ növények és állatok kártételét.
\end{itemize}

A felhasználási területek közül fõként a katasztrófavédelemnél kiemelten fontos, hogy az érzékelés pillanatától számítva 
mennyi késéssel juthatunk hozzá a kiértékelt adatokhoz - árvíz esetén például órák alatt változhat a vízszint, amelyrõl ha idõben
értesülünk, megtehetjük a megfelelõ óvintézkedéseket, késlekedés esetén azonban jelentõs károk keletkezhetnek. A mûholdak visszatérési
ideje csupán egy tényezõ az eredmény elõállításának gyorsaságában - kritikus lehet a meglévõ adatok kiértékelésének sebessége is.

\section{Távérzékelt felvételek feldolgozása}
A távérzékelés általánosságban a felvételezéstõl a tematikus információ-kivonásig tart. Elsõ lépésként a felvételek egy elõfeldolgozó
fázison mennek keresztül, majd ezt követi a felvételek kiértékelése. A dolgozat során elemzett mûveletek egy része az elõfeldolgozásban, 
a többi mûvelet pedig a képelemzésben használt, így megfelelõ képet kaphatunk, mely feldolgozási fázisban milyen hatékonysággal 
használható a vizsgált rendszer.

\subsection{Elõfeldolgozás}
Manapság számos mûhold szolgáltat távérzékelt ûrfelvételeket, melyek - a megfelelõ eszközök birtokában - 
bárki számára hozzáférhetõk. A mûholdak által szolgáltatott nyers adatok számos hibaforrással lehetnek terheltek, melyeket lehetõség szerint
ki kell küszöbölni. Ide tartoznak például a \textit{légköri zavaró hatások}(páratartalom, hõmérséklet-különbségek), a felvevõ rendszer és
hordozóeszközének mozgási szabálytalanságaiból adódó \textit{torzítás}ok, valamint a szomszédos területekrõl való \textit{átsugárzás}.
A hibaforrások kiküszöbölése mellett a hatékony feldolgozás érdekében érdemes minden felvételt egységes geometriai rendszerbe transzformálva
kezelni, melyet \textit{geometriai korrekció}nak nevezünk.

\textit{Intenzitás-korrekció} alatt azokat a mûveleteket értjük, melyekkel a felvétel képpontjaioz és az egyes spektrális sávokhoz tartozó
sávonkénti intenzitást módosítjuk. Ide tartozik például a \textit{radiometriai korrekció}, valamint a különbözõ látványjavító mûveletek.
\textit{Radiometriai korrekció} alkalmazásával következtethetünk a földfelszín fizikai paramétereire. Az elsõ lépés a szenzorhoz ténylegesen eljutó
sugárzás, a \textit{radiancia} mennyiségének megállapítása. 
Ebbõl számítható a \textit{ToA-reflektancia} (\textit{Top of Atmosphere - a légkör tetején mérhetõ reflektancia}), 
mely a visszavert és a beesõ sugárzás arányának olyan közelítése, mely nem veszi figyelembe a sugárzás és a légkör közötti kölcsönhatást.

Az egyes látványjavító mûveletek célja a felvétel vizuális megjelenítési tulajdonságainak megváltoztatása az emberi szemmel történõ
értelmezés könnyítése érdekében. Látványjavító mûvelet például az \textit{invertálás}, valamint a különbözõ \textit{szûrések}. \cite{remoteSensingLecture}

\subsection{Tematikus osztályozás}
A felvételkiértékelés célja a felszínborítás, földfelszíni objektumok fizikai jellemzõinek megállapítása. A felvételkiértékelés két alapvetõ módszere a 
\textit{vizuális interpretáció} és a \textit{kvantitatív, numerikus kiértékelés}. 

A vizuális interpretáció során a tematikus döntéseket a felvételen \textit{látható} információ alapján hozza meg a
kiértékelõ személy - ez olyan esetekben hatékony eljárás, amikor \textit{geometriai összefüggések}, 
\textit{struktúrák} felismerésére van szükség, melyet a számítógép nem képes azonosítani.

Numerikus kiértékelés esetén a tematikus döntések meghozatala a számítógépen, 
elõre megadott feltételek alapján történik. A számítógépes feldolgozás elõnye, hogy nagy mennyiségû
adat feldolgozására is alkalmas, illetve az egyes textúrák közötti tónuskülönbségek mérésében és elkülönítésében
is jobban teljesít, mint az emberi szem és agy rendszere. Mivel mindkét módszer rendelkezik jelentõs elõnyökkel
a másikkal szemben, gyakran együttesen kerülnek alkalmazásra. 

A \textit{tematikus osztályozás} egy kvantitatív kiértékelési mód, melynek célja egy olyan tematikus térkép
elkészítése, mely véges számú célosztállyal írja le a vizsgált területet. A tematikus térkép minden pixeléhez a
célosztály egy értéke tartozik.

A tematikus osztályozási módszerek lehetnek pontonkénti mûveletek,
melyek figyelmen kívül hagyják a homogén területek szomszédos képpontjainak azonosságát (pl.: \textit{küszöbölõ eljárások}),
valamint szegmensenkénti mûveletek amelyek már homogén területek sorozatán képesek elvégezni az osztályozást 
(pl.: \textit{klaszterezés}). Ezen homogén területek feltárásának és összekapcsolásának módja a \textit{szegmentálás}.
A szegmentálás eredményeként egy tematikus térképet kapunk, mely minden képpontra megadja a pontot 
tartalmazó szegmens sorszámát. Szegmentálás használata esetén elmondható, hogy homogén területen a kategóriák
kevésbé keverednek.

%TODO Replace with better figure
\begin{figure}[ht!]
	\centering
	\captionsetup{width=0.6\textwidth, justification=centering}
	\includegraphics[width=110mm]{figures/coordinateSystem2.jpg}
	\caption{Az egyes felszíndarabok sugárzási értékei  $x_1 = 0.5\si{\micro\metre}$ 
		és $x_2 = 0.9\si{\micro\metre}$ hullámhosszon \label{intensitySpaces}}
\end{figure}

A tematikus osztályozás a képpontok vagy szegmensek \textit{intenzitástér}ben való elhelyezkedése alapján 
határolja be az egyes elemeket a megfelelõ osztályokba. Az intenzitástérben a kép egy pixelének sávonkénti
intenzitásértékei adják a pont koordinátáit. A \ref{intensitySpaces}. ábrán látható, hogy az egyes intenzitásértékek
jellemzõen nem pontokba tömörülnek, hanem rendelkeznek bizonyos mértékû szórással. A tematikus osztályozás során
ezen térben keressük az összetartozó elemeket, és ez alapján alakítjuk ki a végsõ osztályhalmazokat. 
\cite{remoteSensingLecture}

\subsection{Feldolgozó mûveletek munkaterülete}
A feldolgozó mûveletek munkaterülete azt határozza meg, hogy egy lépés végrehajtásához mekkora adathalmazra
van szükség. Ez alapján négy csoportot különböztetünk meg

\begin{itemize}
	\item \textit{Lokális mûvelet:} A forrás egy megadott képpontjából a cél egy képpontját állítja elõ,
	lényegében egy pontból pontba történõ transzformáció. Ebbe a csoportba tartoznak az egyszerûbb képi
	transzformációk, mint az \textit{invertálás}, valamint az egyes \textit{küszöbölõ} algoritmusok.
	\item \textit{Fokális mûvelet:} Egy megadott képpont kiszámításához annak valamilyen sugarú környezetében lévõ
	értékek felhasználásával dolgozik. Ide tartoznak például a különbözõ \textit{szûrõ} mûveletek.
\end{itemize}

\begin{figure}[h!]
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/localOperation.png}
	{\caption{Lokális mûvelet}}\label{fig:localOperation}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/focalOperation.png}
	\caption{Fokális mûvelet}\label{fig:focalOperation}
	\endminipage\hfill
\end{figure}

\begin{itemize}
	\item \textit{Regionális (zonális) mûvelet:} %TODO Recompose 
	A regionális mûveletek hasonlóak
	a fokális mûveletekhez, leszámítva hogy míg a fokális mûveletnél a képpont kiszámításához szükséges környezet
	egy elõre definiált
	méretû terület, addig a zonális mûveletnél a szükséges környezet az õt tartalmazó régió (zóna), 
	mely a feldolgozás során dinamikusan változhat. Regionális mûvelet például a legtöbb \textit{szegmentáló}
	algoritmus
	
	\item \textit{Globális mûvelet:} Az eredménykép minden képpontjának elõállításához rendelkeznie kell a teljes
	forráskép ismeretével. Ide tartoznak például azok a \textit{küszöbölõ eljárások}, melyek
	a küszöbértéket a teljes képbõl számított valamilyen statisztika (pl.: Hisztogram) alapján határozzák meg. 
	A legtöbb \textit{klaszterezõ algoritmus} is ebbe a kategóriába tartozik, mivel a klaszterek
	kialakítása	során a képpont elhelyezkedését már nem vesszük figyelembe, csupán a spektrális tulajdonságait.
\end{itemize}

\begin{figure}[h!] %TODO Mark with citation
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/zonalOperation.png}
	{\caption{Regionális mûvelet}}\label{fig:zonalOperation}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/globalOperation.png}
	\caption{Globális mûvelet}\label{fig:globalOperation}
	\endminipage\hfill
\end{figure}

A mûveletek ezen tulajdonsága kulcsfontosságú az elosztott feldolgozás témakörében - lokális mûveletek esetén 
a feldolgozandó adat könnyedén particionálható, a feldolgozás pedig tetszõleges számú párhuzamos szálon futtatható.

Fokális mûveleteknél biztosítanunk kell, hogy az egyes képpontok mindegyike rendelkezzen információval a környezetérõl
- ezt megtehetjük például a partíciókra bevezetett \textit{átfedés} definiálásával, központi
\textit{utófeldolgozás}sal, illetve ha lehetõségünk van az egyes partíciókon futó folyamatok közvetlen 
kommunikációjára, a szükséges pixelértéket elkérhetjük a vele rendelkezõ folyamattól.

Regionális mûveletek esetén a fokális mûveletekhez hasonlóan biztosítanunk kell a környezõ értékek elérését. Itt 
jellemzõen az átfedéses megoldás nem célravezetõ, tekintve hogy nincs információnk a folyamat elindításának
pillanatában, mekkora területre lesz szükség az egyes képpontok kiszámításához, ez az információ a mûvelet futása alatt
dinamikusan változhat.

Sok esetben globális mûveletek is elvégezhetõk particionált módon, itt azonban mindenképp szükséges egy központi
összefuttató lépés - ennek módszere az alkalmazott mûvelettõl függ.\cite{remoteSensingLecture}

\section{Adatkezelés}
Az alkalmazási területeknél már említésre került, hogy a feldolgozási idõ kritikus lehet az adatkiértékelés szempontjából.
Ezt nehezíti az a tény, hogy a kiértékelõ eljárások többsége meglehetõsen komplex, illetve hogy gyakran hatalmas mennyiségû
adathalmazzal kell dolgoznunk.
Ez felveti olyan megoldások kutatásának szükségességét, amellyel a kiértékelés ideje csökkenthetõ.

A legkézenfekvõbb lehetõség a feldolgozó egységek \textit{számítási kapacitás}ának megnövelése. Erõsebb \textit{processzor}, 
több \textit{memória}, I/O mûveletek gyorsabb elvégzésére alkalmas \textit{háttértár}ak
beszerzése esetén a számítási teljesítményünk is növekszik. A megoldás legnagyobb elõnye, hogy a meglévõ algoritmusok a megnövelt 
teljesítményû környezetben is felhasználhatóak, a feldolgozás szoftveres része nem igényel adaptációt. Azonban a
rendszer teljesítménynövelésének ezen módja költséges, és a fejlesztéssel nyert számítási kapacitás aránya egy bizonyos szint után csökken.

A teljesítménynövelés másik lehetséges módja az évek óta kutatott\cite{distributedImageProcessing}, és a számítási
felhõk elterjedésével az utóbbi idõben leginkább teret nyert \textit{elosztott feldolgozás}.

Távérzékelt felvételek elosztott feldolgozása úgy történik, hogy a feldolgozandó kép alkotó elemeit valamilyen tulajdonság alapján 
(pixel értékek, spektrális intenzitásértékek) \textit{feldarabolunk} (\textit{particionálás}), az egyes feldolgozó egységek pedig ezen darabokat dolgozzák fel.
Ekkor - a mûvelet korábban ismertetett munkaterületének megfelelõen - a feldolgozó egységeknek szükségük lehet olyan információkra, melyek
a teljes adat egy részének vagy egészének ismeretében számíthatók csak ki. 
Egyszerûbb esetben ezt megoldhatjuk \textit{átfedések} alkalmazásával - az input adatot úgy particionáljuk,
hogy az eredetileg neki szánt területnél valamennyivel nagyobb területet tartalmazzon. 
Ez fõként fokális mûveleteknél hasznos, ahol a pixelek kiszámítása egy meghatározott sugarú környezet
pixelértékeinek felhasználásával történik. Ekkor az átfedések segítségével akár más partíció felhasználása 
nélkül is kiszámítható az eredmény.

\begin{figure}[ht!]
	\centering
	\captionsetup{width=0.6\textwidth, justification=centering}
	\includegraphics[width=80mm]{figures/imagePartitioning_withOverlap.png}
	\caption{Input kép feldarabolása \textit{átfedés}ek alkalmazásával \label{fig:imagePartitioning}}
\end{figure}

Regionális esetben is felhasználhatóak az átfedett területek, azonban az egyes régiók méretének
dinamikus változása miatt kisebb valószínûséggel lesz elég az átfedések által tartalmazott adat.
Emiatt szükséges lehet a feldolgozó egységeknek egymással kommunikálniuk feldolgozás közben,
hogy biztosíthassák a számításokhoz szükséges adatokat. Ezen adatok gyors és hatékony 
rendelkezésre állása kulcsfontosságú egy elosztott rendszer teljesítményében.

% ------------------------------------------------------------------------------

\chapter{Elosztott alkalmazások fejlesztése}
A fejezetben bemutatásra kerülnek a fõbb elosztott szoftverrendszerek elméleti alapjai, ezek néhány megvalósítása, valamint
távérzékelt felvételek feldolgozásában lévõ alkalmazási lehetõségeik, külön részletezve a dolgozat
témáját, a \textit{Microsoft Orleans} platformot.

Az \textit{elosztott rendszerek} olyan szoftverrendszerek, melyek komponensei fizikailag elkülönítve futnak, és futás során
egymással hálózaton keresztül kommunikálnak. A komponensek saját processzorral és memóriával rendelkeznek (Szemben a párhuzamos
rendszerekkel, amelyek a memóriát megosztják egymással).

Az elosztott architektúra több jelentõs elõnnyel is rendelkezik az egy számítási egységgel rendelkezõ rendszerrel szemben:
\textit{skálázhatóság} (a folyamat áteresztõképességének növelésének képessége), nagyobb \textit{hibatûrés}, 
hatékony \textit{terheléselosztás}, olcsó \textit{bõvíthetõség}.
Az elosztott feldolgozás hátránya a \textit{komplexitás}ában nyilvánul meg - 
az egyes komponensek egymással való \textit{hálózati kommunikáció}ját 
biztosítani kell, a kommunikációból adódó késést figyelembe kell venni, illetve kezelni kell a fellépõ \textit{konkurenciá}t.
A hibaelhárítás, valamint a diagnosztizálás is sokkal bonyolultabbá válhat egy elosztott rendszerben.

Ezen tényezõk indokolták olyan \textit{keretrendszerek} és \textit{architekturális koncepciók} kutatását, 
melyek az elosztott alkalmazások fejlesztésének nehézségeire részben vagy egészben megoldást nyújtanak.
A következõ részekben ezen koncepciók és néhány megvalósításuk kerül bemutatásra.

\section{MapReduce}
A \textit{MapReduce} nagy adathalmazok generálására és feldolgozására fejlesztett számítási modell.\cite{mapReduce}
Egy MapReduce alkalmazás alkotóelemei \textit{Map} és \textit{Reduce} funkciók. A \textit{Map} funkció az input
elemeibõl köztes \textit{kulcs/érték párok}at állít elõ, a \textit{Reduce} mûvelet pedig összevonja az összes olyan
köztes elemet, melynek kulcsa megegyezik.
A MapReduce paradigma alapján írt programok automatikusan párhuzamosíthatók, és skálázhatók. 
A futtatókörnyezet végzi az adatok \textit{particionálás}át, vezérli a végrehajtást, kezeli a 
\textit{gépek közötti kommunikáció}t és a fellépõ hibákat.
Ezzel lehetõséget nyújt elosztott környezetek erõforrásainak kihasználására anélkül, hogy a fejlesztõktõl 
komoly szaktudást követelne a párhuzamos és elosztott alkalmazásfejlesztés területén.

\begin{figure}[ht!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=120mm]{figures/mapReduce.jpg}
	\caption{A \textit{MapReduce} folyamat \label{mapReduceProcess}}
\end{figure}

\subsection{Hadoop}
A MapReduce modell egy implementációja az \textit{Apache Software Foundation} által fejlesztett 
\textit{Hadoop} keretrendszer. A rendszer komponenseinek tervezésénél a fõ szempont a hibatûrés volt - 
bármilyen hardveres hiba elõfordulása természetes, és a keretrendszernek automatikusan kezelnie kell.

A rendszer három fõ komponensbõl áll: A \textit{Hadoop Elosztott Fájlrendszer}bõl 
(\textit{HDFS - Hadoop Distributed File System}), a \textit{Hadoop MapReduce} adatfeldolgozóból, valamint
a \textit{Hadoop YARN}-ból, mely a rendszer erõforrás-kezelõje.
A Hadoop a fájlokat blokkokra osztja, és szétosztja az egyes \textit{node}-ok között. Az adatok feldolgozása
során a Hadoop a feldolgozó szoftvert tölti fel minden \textit{node}-ra, így az adatok helyben kerülnek
feldolgozásra (\textit{adatlokalitás}).

\subsubsection{Térinformatikai alkalmazása}
A Hadoop keretrendszer fejlesztésekor az alkalmazás fõ célterülete szöveges adatok feldolgozása volt.
A rendszer terjedésével azonban megjelent az igény az informatika több különbözõ területén való
alkalmazására. Ennek megfelelõen megjelentek a keretrendszer térinformatikai kiterjesztései is
\cite{spatialHadoop,hadoopGIS}, melyek
támogatják téradatok tárolását, indexelését, és \textit{MapReduce} alapú feldolgozását.
Az egyes feldolgozó mûveletek közül a lokális, illetve a fokális mûveletek könnyedén alkalmazhatók
egyszerû \textit{Map} függvényekként, regionális és globális esetben általában szükséges egy olyan
alternatív algoritmus bevezetése, amely az eredeti algoritmus kiegészítése egy (vagy több) 
\textit{Reduce} lépéssel.

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm]{figures/histogram_map_reduce.jpg}
	\caption{Hisztogramkiegyenlítés \textit{MapReduce} alkalmazásával \cite{aegisHadoop}
		\label{fig:histogram_map_reduce}}
\end{figure}

Például a \textit{hisztogram kiegyenlítés} mûvelet egy globális mûvelet, melynek szüksége van az egész képre vonatkozó
hisztogram értékekre. Ekkor Hadoop architektúrán a mûvelet három különbözõ lépésbõl áll. Elõször egy \textit{Map}
függvényben kiszámítjuk az egyes hisztogram értékeket minden fájldarabra. A második, \textit{Reduce} lépés
összefésüli ezeket az értékeket, és elõállítja a teljes hisztogramot. A harmadik lépésben pedig egy újabb \textit{Map}
utasítás alkalmazza a hisztogramkiegyenlítést a kiszámított teljes hisztogramértékek alapján.

Összességében elmondható\cite{aegisHadoop}, hogy a legtöbb esetben a mûveletek könnyedén adaptálhatók Hadoop környezetbe, 
azonban néhány alkalommal komplex módosításokra van szükség, és a portolt algoritmus helyfoglalási idénye sokkal nagyobb
lehet, mint az eredeti mûveleté. Ezen tényezõk indokolták további alternatív feldolgozó mechanizmusok kutatásának szükségét.

\section{Aktor modell} %TODO Extend
Az \textit{Aktor modell} egy olyan konkurens matematikai modell, melynek alapegységei az "\textit{aktorok}" \cite{actorOrig}.
Az aktorok egymástól izolált egységek, melyek direkt módon, aszinkron \textit{immutable} üzeneteken keresztül kommunikálnak egymással.
Minden aktor rendelkezik egy "postaládával", ahová az üzenetek érkeznek, ezeket az üzeneteket dolgozza fel sorban 
- számítást végezhet, aktorokat hozhat létre, 
további üzeneteket küldhet, valamint beállíthatja, hogyan fog reagálni a következõ üzenetre.
Az üzenetek sorrendje nem garantált, de követelmény, hogy minden üzenet beérkezzen.

\begin{figure}[H]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=120mm]{figures/actorModel.png}
	\caption{Az \textit{aktor modell}. Mindegyik aktor rendelkezik egy saját postaládával,
		 és izoláltan eltárolja az állapotát
		\label{fig:actorModel}}
\end{figure}

Az aktorok jellemzõen egy számítási szállal rendelkeznek, és nem osztanak meg memóriát egymás között. 
Ez eliminálja a versenyhelyzetek kezelésének szükségességét aktor szinten. 
A fejlesztõknek nem szükséges \textit{lock}olást, \textit{mutex}eket és más versenyhelyzet-kezelõ megoldásokat
alkalmazniuk, melyek nem tartoznak az alkalmazás logikájához. Az aktorok dinamikusan jönnek létre
a rendelkezésre álló erõforrások alapján, ezáltal hatékony terheléselosztás alkalmazható.

Az aktor modell akkor alkalmazható hatékonyan, ha az aktorok "könnyûsúlyúak", gyorsan példányosíthatók,
és folyamatuk nincs a rendszermag szálaihoz kötve, attól eltérõen ütemezhetõ.

\subsubsection{Aktor implementációk}
A modellt elõször az \textit{Erlang} programozási nyelvben alkalmazták konkurens alkalmazások fejlesztésére \cite{actorErlang}, majd a modell népszerûségének 
növekedésével több nyelv és keretrendszer is sikeresen 
adaptálta a modellt, pl.: a \textit{Scala} \cite{actorScala}, 
vagy az \textit{Akka} keretrendszer\cite{actorAkka}.

Ezek az aktor modell implementációk - jóllehet hatékony megoldást adnak az elosztott 
alkalmazásfejlesztésre - több elosztott rendszerrel kapcsolatos probléma kezelését a 
fejlesztõkre bízzák. A fejlesztõknek kezelniük kell az aktorok életciklusát (hiba esetén történõ leállás esetén az aktorok újraaktiválását), a rendszerben
történõ elhelyezését, valamint versenyhelyzetek kezelését. Ezek a limitációk, és a 
kiküszöbölésükre való törekvés hívta életre a \textit{Microsoft Orleans} keretrendszert.


\section{A Microsoft Orleans platform} %TODO Mention Azure
Az \textit{Orleans} egy - a \textit{Microsoft Research} által fejlesztett - keretrendszer, 
mely lehetõséget ad megbízható és skálázható felhõalapú alkalmazások fejlesztésére.

Az Orleans programozási modellje (\textit{Virtual Actor Model - Virtuális Aktor Modell})
az aktor modell egy olyan kiterjesztése, amely az aktorokat virtuális entitásokként kezeli, mely eliminálja a 
az elosztott erõforráskezelés és a megbízhatóság alkalmazás szinten történõ kezelését, megszünteti a konkurenciát, ezáltal
nem követel komplex tudást a fejlesztõktõl az elosztott alkalmazásfejlesztés területén.

A keretrendszert a \textit{Microsoft Windows Azure} számítási \textit{felhõben} több jelenleg is futó projekten 
hatékonyan alkalmazták, 2015 januárjában pedig nyílt forráskódú licenccel a nyilvánosság elé tárták.

\subsection{Virtuális Aktor modell}
Az Orleans rendszer egy módosított Aktor modellt definiál, amelyet elosztott alkalmazások, valamint az
Erlang nyelv Aktor modellének implementációja ihletett, és teljes egészében a .NET keretrendszerre épül.
Az Orleans aktorok (\textit{Grain}, szabad fordításban \textit{szemcse, gabonaszem}) a rendszer legkisebb
számítási alapegységei. Egy aktor enkapszulálja az állapotát és a viselkedését, és nem
oszt meg memóriát más aktorokkal, így két aktor között az egyetlen kommunikációs mód az aszinkron üzenetküldés.

Az aktorok az Orleans rendszerben a tradicionális modelltõl eltérõen virtuálisak. 
Egy aktor elméletben mindig létezik, nem hozható létre és nem semmisíthetõ
meg manuálisan. Az aktorok létezése nem függ a példányok számától, és nem függ futtató szerver állapotától.
Mivel az aktorok mindig léteznek, ezért mindig elérhetõek.
Az Orleans futtatókörnyezet automatikusan kezeli az aktorok példányosítását (\textit{aktiváció}) és megsemmisítését. 
Az alkalmazás futása során minden idõpillanatban egy aktor 0, 1 vagy több aktivációval rendelkezik.
Ha egy üzenet érkezik egy aktornak, és nincs egyetlen aktivációja sem, a rendszer létrehoz egy példányt az egyik elérhetõ 
szerveren (\textit{Orleans Silo}), valamint ha a példány egy bizonyos ideig kihasználatlanul marad, 
a futtatókörnyezet elvégzi a példány deaktiválását és felszabadítását. Ha egy szerver hiba miatt leáll, az 
Orleans egy másik elérhetõ szerveren automatikusan újrapéldányosítja azokat az aktorokat, 
amelyek a hibás szerveren futottak, és a nekik küldött üzeneteket erre az új szerverre irányítja.
Az alkalmazásoknak így nincs szükségük különbözõ \textit{életciklus felügyelet}i logika bevezetésére
(pl.: \textit{felügyeleti fák} az Erlang nyelvben \cite{erlang}).
Az aktorok automatikus példányosítása és életciklus-kezelése azt is eredményezi, 
hogy az aktorok fizikai elhelyezkedésérõl a futó alkalmazásnak nincs tudomása - 
egy bizonyos idõpillanatban egy aktornak akár 0 vagy egynél több aktivációja is lehet, ezt a 
keretrendszer tartja nyilván.

Jelenleg az Orleans rendszer kétféle aktivációs módot támogat: az \textit{állapot}tal rendelkezõ aktorok
egyszerre maximum egy aktivációval rendelkezhetnek, míg az \textit{állapotmentes} (\textit{Stateless Worker})
aktoroknak szimultán több egymástól független aktivációja is megengedett a klaszterben.

\subsubsection{Aktorok kommunikációja}
Az egyes aktorok azokon a metódusokon keresztül tudnak kommunikálni egymással, 
melyek az aktor interfészében definiálásra kerültek. Az összes metódus amelyet az interfészen
definiáltak, aszinkron (\textit{Task} visszatérési értékû) kell, hogy legyen.

Ahhoz, hogy egy aktor üzenetet küldhessen egy másik aktornak, szükséges \textit{referenciá}val
rendelkeznie a másik aktorra. Ezek a referenciák virtuálisak abban a tekintetben, hogy nem 
szolgálnak semmilyen információval a referált aktor fizikai elhelyezkedésérõl. 
A kommunikáció egy lokális \textit{proxy objektum}on keresztül történik, és az üzenetet
a futtatókörnyezet továbbítja a tényleges aktornak.

Az egyes üzenetek szerializálva kerülnek továbbításra - a beépített .NET [Serializable]
attribútummal ellátott objektumok is használhatók és az Orleans keretrendszer is rendelkezik
beépített szerializálóval, amely képes tömbök, illetve generikus objektumok 
szerializálására is, mindezek mellett pedig megtartja az objektumok identitását 
(ha két pointer ugyanarra az objektumra mutat, akkor deszerializálás után 
is ugyanarra az objektumra fognak mutatni).

\subsubsection{Elosztottság, Fordulók} 
Az aktorok minden aktivációja egyszálú, és \textit{fordulók}nak nevezett részletekben dolgoznak.
Az Orleans rendszer különbözõ aktivációk fordulóit futtathatja párhuzamosan, azonban minden
aktiváció csupán egy fordulót dolgoz fel egyszerre.
Ennek eredményeként aktor szinten nem jelenik meg párhuzamosság a rendszerben.
A forduló alapú modell ugyan megengedi több kérés fordulóinak átfedését 
(pl.: Amíg az egyik forduló egy \textit{I/O mûvelet} befejeztére vár,
egy másik forduló feldolgozása is elkezdõdhet), azonban ezt az Orleans rendszer
alapértelmezetten nem engedélyezi. Ez a viselkedés felüldefiniálható, és a fordulók
átfedhetnek, ha az aktor osztályt megjelöljük a [Reentrant] attribútummal.

\subsection{A keretrendszer implementációja}

Az Orleans rendszer egy szerverek egy csoportján fut, és három fõ alrendszere van - 
\textit{Üzenetküldés}, \textit{Végrehajtás} valamint \textit{Futtatókörnyezet}. %TODO come up w/ better name 4 hosting

Az üzenetküldés alrendszer minden szervert egyszerû TCP kapcsolattal köt össze, 
és több kommunikációs szálon keresztül továbbítja az egyes üzeneteket.

A környezet alrendszer dönt az aktivációk elhelyezésérõl a klaszterben, a
végrehajtás pedig a rendelkezésre álló számítási szálak alapján futtatja az
aktorok kódját.

Amikor egy aktor egy másik aktort hív, a Végrehajtás a függvényhívást üzenetté
konvertálja, és átadja az üzenetküldésnek a cél aktor identitásával együtt.
Az üzenetküldés lekéri a környezettõl, hogy melyik szerver hosztolja
az aktort. A környezet egy \textit{elosztott könyvtár} segítségével tartja nyilván
az aktorok összes aktivációját a rendszerben. A könyvtárban vagy egy létezõ aktivációt
talál, vagy kiválaszt egy szervert, és létrehoz egy új aktivációt. Az üzenetküldés 
ezután szerializálja az üzenetet, és a nyitott TCP kapcsolaton keresztül továbbítja 
a célszervernek. A célszerver üzenetküldés alrendszer deszerializálja az üzenetet,
és átadja a végrehajtásnak, mely ezután ütemezi a hívást. Ha egy aktor éppen egy
másik hívást dolgoz fel, az üzenet sorban áll addig, amíg a feldolgozás be nem fejezõdik.

%TODO Add figure
%\begin{figure}[ht!]
%	\centering
%	\includegraphics[width=90mm]{figures/}
%	\caption{
%	\label{fig:}}
%\end{figure}

A környezet felel a lokális erõforrások kezeléséért is. Ha egy aktorra egy bizonyos
(elõre definiált) ideje nem volt szükség, vagy ha a szerver erõforráshiányt észlel,
a környezet automatikusan deaktiválja az aktort, és visszaveszi az erõforrásait.

\subsubsection{Izoláció}
Az Orleans aktorok nem osztanak meg memóriát és izoláltak egymástól.
Az aszinkron üzenetküldés az egyedüli kommunikációs mód köztük, amelyek
metódusok formájában jelennek meg az aktorok interfészén. Ezen felül a metódushívások
paraméterei és visszatérési értékei a hívás során lemásolódnak (még akkor is,
ha a metódushívás két ugyanazon a szerveren lévõ aktor között megy végbe),
ezzel biztosítva hogy az elküldött üzenet ne módosulhasson.

\subsubsection{Kooperatív multitasking}
Az Orleans az egyes fordulókat \textit{kooperatív multitasking} formában ütemezi. Ez azt jelenti, hogy
egy alkalmazás forduló az elindítása után megszakítás nélkül végrehajtódik. Az Orleans ütemezõje
az aktorok futtatásához és ütemezéséhez tipikusan annyi számítási szálat használ, 
amennyi processzormaggal rendelkezik az adott rendszer. 

Egy komplex rendszerben az aktor aktivációk száma akár milliós nagyságrendû is lehet. 
\textit{Preemptív multitasking} használata esetén az összes aktiváció saját szálat kapna, ez pedig egy bizonyos
számú aktiváció felett több lenne, mint amit a rendszerek képesek kezelni, ráadásul a kontextusváltás
drága, így ez is rontana a teljesítményen.

\subsubsection{Megbízhatóság}
A rendszer a megbízhatóság összes aspektusát automatikusan kezeli, kivéve az aktorok perzisztens állapotának
menedzselését. A rendszer automatikusan menedzseli a klaszterben lévõ szervereket. Az egyes szerverek
\textit{ping} üzeneteket küldenek egymásnak, és ha egy bizonyos szervertõl több másik szerver sem kap választ,
akkor a szervert leálltnak tekintik.

Ha egy szerver leállt, az összes rajta futó aktiváció elveszik. Ekkor a többi szervernek ezekre az aktivációkra
vonatkozó információkat ki kell törölniük a rendszer elosztott könyvtárából. 
Mivel az aktorok virtuálisak, egy aktor nem áll le ha az õt futtató szerver leáll.
Ehelyett a következõ üzenet, amelyet a leállt szerveren lévõ aktornak küldenek, egy új aktivációt fog létrehozni
egy másik, élõ szerveren. 

Egy aktor állapotának mentési stratégiája nagymértékben függ az aktor feladatától. Ha például
az aktorunk egy eszközt (\textit{mobiltelefon}, \textit{szenzor}) reprezentál, melyet az eszköz az adataival
periodikusan frissít, akkor nem szükséges elmentenünk az aktor állapotát, mivel az új aktiváció a következõ
frissítéssel küldött adatokból képes lesz azt elõállítani.
Ha nem engedhetünk meg állapotvesztést, akkor a mentés minden üzenet feldolgozása után szükséges, 
vagy megengedõbb esetben, megadott idõközönként esedékes a mentés.

Tekintve, hogy egy aktor (és az egész rendszer) teljesítményét nagymértékben befolyásolhatja, és minden aktorra
különbözhet a mentési stratégia, a rendszer nem kezeli az állapotok automatikus mentését, ezt a fejlesztõkre bízza. 

\subsubsection{Aktorok elhelyezése}
Az Orleans rendszer futása során automatikusan és transzparensen hozza létre az aktorokat.
Ez azt jelenti hogy nem szolgáltat információt azok fizikai elhelyezkedésérõl, 
tehát arról, hogy a létrehozott \textit{Grain} aktiváció melyik szerveren helyezkedik el a klaszterben.
Az aktorok elhelyezését direkt módon nem vezérelhetjük, azonban a \textit{Placement} attribútumok
használatával egy \textit{Grain} osztályon, közvetetten befolyásolhatjuk, hová "szeretnénk", 
hogy az új aktiváció kerüljön. 

Az Orleans jelenleg 3 fajta elhelyezési (\textit{Placement})
stratégiát támogat: 
\textit{Aktivációk száma alapján} történõ elhelyezés (\textit{ActivationCountBasedPlacement}), 
\textit{Lokális} elhelyezés (\textit{LocalPlacement}), 
valamint \textit{véletlenszerû} elhelyezés (\textit{RandomPlacement}). A véletlenszerû elhelyezés 
használatával az összes szerverre egyenlõ valószínûséggel kerül az új aktiváció. Lokális elhelyezés
során az aktivációt kérõ \textit{Grain} szerverére történik az elhelyezés. Ha az aktiváló nem egy 
\textit{Grain}, hanem a kliens volt, ennek az elhelyezési stratégiának nincs hatása, és a 
\textit{RandomPlacement} stratégia alapján kerül az új aktiváció elhelyezésre. Az aktivációk száma alapján
történõ elhelyezés a legkevesebb aktivációval rendelkezõ szerverre helyezi el a 
kért \textit{Grain} aktivációt.

\subsection{Orleans projektek felépítése} \label{subs:orleansProjects}
Egy Orleans alkalmazást 3 fõ komponens épít fel: \textit{Aktorok} (\textit{Grains}), 
\textit{Aktor interfészek} (\textit{Grain Interfaces}) valamint a \textit{Kliens} (\textit{Client}). Ezek a komponensek 
különálló alprojektekként jelennek meg a rendszerben.

A \textit{Grain interfaces} komponensben definiálhatjuk a projektben használt aktorokat, 
valamint ezek metódusait és a metódusok szignatúráját. Csak az itt definiált aktor típusok lesznek késõbb
felhasználhatóak, melyek implementációját a \textit{Grains} komponens tartalmazza.

A \textit{Client} komponens köti össze a külvilágot a rendszerrel, tulajdonképp egy belépési pont
az Orleans környezetbe. A kliens rendelkezhet \textit{Grain} referenciákkal, 
valamint üzenetet is küldhet \textit{Grain}-eknek. A megfelelõ kommunikáció érdekében a \textit{Client}
illetve a \textit{Grains} komponensnek is rendelkeznie kell ugyanazzal a \textit{Grain Interfaces} komponenssel.


\subsection{Alkalmazási lehetõségek} %TODO Not the best section title.
Az Orleans környezet alapvetõen a \textit{Szolgáltatás-orientált architektúra} jegyében épült alkalmazások fejlesztését
támogatja - egymástól teljesen izolált, önálló szervizek összessége, melyek jól skálázódnak, és egy meghatározott 
mûvelet elvégzésére képesek. Egy komplex alkalmazás több száz, vagy akár több ezer szervizbõl is állhat, és a szervizek
száma az alkalmazás terheltségének változásával dinamikusan nõhet, illetve csökkenhet.
A szervizek tipikusan nem komplex, mûveletigényes számítások elvégzésére alkalmasak, fõ szempont a reszponzivitás. 

Ennek megfelelõen az Orleans aktorok egymástól izolált egységek, melyek nem osztanak meg memóriát egymással,
az egyedüli kommunikációs lehetõség közöttük az aszinkron üzenetküldés. Egy számítási szállal rendelkeznek, és 
alapértelmezés szerint az aktor entitás egyszerre csak egy üzenetet dolgozhat fel, a többi beérkezõ üzenet blokkolódik.
Mivel az aktorok virtuálisak, így a futtatókörnyezet az skálázást a terhelésnek és a rendelkezésre álló 
erõforrásoknak megfelelõen alakíthatja.

\subsubsection{Térinformatikai alkalmazás}

A dolgozat által vizsgált feladat számos ponton különbözik a fent felsorolt szempontoktól - távérzékelt adatok
feldolgozásához gyakran hatalmas méretû adatokkal kell dolgoznunk, a mûveletek költségesek, és akár több 
órát is igénybe vehetnek, valamint a mûveletek legtöbbjének párhuzamosítása esetén az egyes folyamatoknak más
folyamatok adataihoz is hozzá kell férniük. A dolgozat része volt ezen szempontbéli különbségek kiküszöbölése
a megfelelõ eredmény érdekében - a késõbbi fejezetekben az alkalmazott megoldások és az eredmények
részletesen is tárgyalásra kerülnek.

%TODO Extend, Recompose?
Az Orleans térinformatikai kiegészítéséhez szükséges volt egy olyan keretrendszer integrációja és felhasználása,
amelynek segítségével egységesen kezelhetünk és dolgozhatunk fel téradatokat. Így esett a választás az \textit{AEGIS}
keretrendszerre, mely a következõ fejezetben kerül tárgyalásra.

% ------------------------------------------------------------------------------

\chapter{Az AEGIS térinformatikai keretrendszer}
Az \textit{AEGIS} keretrendszer \textit{Eötvös Loránd Tudományegyetem Informatikai Karán} jelenleg is fejlesztés alatt
álló térinformatikai keretrendszer, melynek fõ célja térinformatikai algoritmusok, megoldások \textit{kutatás}a és \textit{fejlesztés}e.
A rendszer téradatok széles spektrumát támogatja, például: \textit{vektoros adathalmazok}, \textit{raszter felvételek}
valamint \textit{pontfelhõk}. A rendszer egy platformfüggetlen osztálykönyvtár, melynek fejlesztése C\# nyelven
történik, alapja a \textit{.NET keretrendszer}, illetve a \textit{Mono Framework}. A fejlesztés a komponens alapú
architektúra jegyében történik, mely lehetõséget ad a rendszer bõvítésére, valamint az újrafelhasználhatóságra.
Ennek segítségével az egyes komponensek könnyedén integrálhatóak más alkalmazásokba\cite{aegis}.
Mindezek mellett az AEGIS keretrendszer rendelkezik azokkal a távérzékelt adatfeldolgozó
mûveletekkel, amelyek a dolgozatban kutatásra kerültek. Ezek alapján a rendszer megfelelõ környezetet
biztosított az Orleans térinformatikai kiegészítésére.

Az AEGIS keretrendszert felépítõ fõbb komponensek: \textit{Core, IO, Operations, Temporal}.
A \textit{Core} komponens a rendszer adatmodellével kapcsolatos osztályokat tartalmazza, az \textit{IO} 
téradatok betöltéséért és írásáért felel (pl.: \textit{Shapefile} vagy \textit{GeoTIFF} formában),  %TODO cite Shapefile and tiff?
az \textit{Operations} komponens tartalmazza a téradatokon végezhetõ mûveleteket, valamint ezek futtatókörnyezetét,
a \textit{Temporal} komponens pedig az adatmodell kiterjesztése idõbeliség kezelésével.

%\begin{figure}[ht!]
%	\centering
%	\includegraphics[width=90mm]{figures/aegis_components.jpg}
%	\caption{Az \textit{AEGIS} rendszer komponensei
%	\label{fig:aegis_components}}
%\end{figure}

\section{Adat-, illetve mûveleti modell}
A rendszer adatmodellje az \textit{Open Geospatial Consortium (OGC)} szervezet által definiált
\textit{Simple Feature Access (SFA)}\cite{sfa} szabvány. A szabványban a központi geometriai 
primitív a \textit{Geometry} osztály, mely a térbeli tulajdonságokat, és az egyes térbeli objektumok 
között elvégezhetõ mûveleteket definiálja. Az adatmodell két-, illetve háromdimenziós vektoros 
adatok tárolására koncentrál, idõbeliség nélkül. Az egyes mûveletek egységes alkalmazhatósága érdekében
az implementáció során a szabvány kiterjesztésre került raszteres adatok támogatásával is, így a 
\textit{Raster} osztály a \textit{Geometry} leszármazottja.

%TODO Replace model
\begin{figure}[h!]
	\centering
	\captionsetup{width=0.9\textwidth, justification=centering}
	\includegraphics[width=120mm]{figures/aegis_data_model_extensions.png}
	\caption{Az \textit{AEGIS} adatmodellje az SFA szabvány alapján, 
		valamint raszteres adatok támogatásával való kiterjesztése
		\label{fig:aegis_data_model}}
\end{figure}
 
Az \textit{Operations} komponensben implementált algoritmusok kezelése is egységes alapon történik, minden mûvelet
közös õse az absztrakt \textit{Operation} osztály. A mûveletek rendelkeznek egy leíró osztállyal is (\textit{OperationMethod})
rendelkeznek, melynek segítségével kategorizálhatjuk a metódusokat, valamint optimalizálhatjuk a végrehajtást.
A mûveletek paramétereinek objektuma az \textit{OperationMethodParameter}, amely tartalmazza a paraméter típusát,
valamint értékét (\ref{fig:aegis_operations}. Ábra).

A mûveletet az Operation osztály \textit{Execute()} metódusával futtathatjuk. Az \textit{Execute()} metódus
futása során rendre három alfüggvényt hív meg, ezek: \textit{PrepareResult(), ComputeResult(), FinalizeResult()}.
A \textit{PrepareResult()} a számításokhoz elõállítja a kiinduló adathalmazt, a \textit{ComputeResult()} a tényleges 
számításokat hajtja végre, a \textit{FinalizeResult()} metódus pedig összegzi és véglegesíti az eredményt.
A leszármazott osztályok ezen metódusok felüldefiniálásával határozhatják meg a mûvelet mûködését.


%TODO Replace model
\begin{figure}[h!]
	\centering
	\includegraphics[width=150mm]{figures/aegis_processing.png}
	\caption{Az \textit{AEGIS} mûveleti modellje
		\label{fig:aegis_operations}}
\end{figure}

Minden térbeli mûvelet, amely vektoros
adatokra definiált (\textit{metszet, projekció}), alkalmazható raszteres felvételekre is.
A csak raszteres adatokon futó mûveleteket (\textit{szûrés, küszöbölés, hisztogram-transzformáció})
pedig olyan metaadattal látjuk el, amely megakadályozza a vektoros adathalmazon történõ futtatást.
Ezek a raszteres mûveletek az \textit{Operations} komponens \textit{Spectral} kiterjesztésében
helyezkednek el. A dolgozat során az itt implementált mûveletek kerültek felhasználásra.

%TODO Can we place a package diagram here?


\section{Feldolgozás Hadoop architektúrán}
Az AEGIS támogatja a \textit{Hadoop} architektúrával történõ adatkezelést, illetve feldolgozást.
A rendszer megfelelõen kezeli nagyméretû bináris adatok \textit{HDFS}-be történõ beolvasását (pl.: \textit{GeoTIFF} formában).
Az input adat opcionálisan particionálható, az egyes partíciók így elosztottan is feldolgozhatók (A fent említett
mûveletek módosítás nélkül alkalmazhatók Map-, illetve Reduce függvényekként).

% ------------------------------------------------------------------------------

\chapter{Megvalósítás}
A fejezet célja az Orleans rendszer távérzékelt felvételek feldolgozására való kiterjesztésének 
a gyakorlatban való bemutatása. Ehhez szükséges volt egy olyan prototípus alkalmazás megvalósítása, 
melynek segítségével tesztelhetõek az Orleans rendszer képességei távérzékelt felvételek feldolgozásában. 
Az alkalmazás felépítésének és mûködésének részletes bemutatása után a vizsgált mûveletek kerülnek taglalásra.

Az egyes munkaterület-csoportokba
tartozó mûveletek csoportonként eltérõ megközelítést igényeltek az elosztott feldolgozás során,
így ezen csoportokon végighaladva tárgyaljuk az alkalmazott ötleteket és megvalósításukat.

\section{Az Orleans térinformatikai kiterjesztése} 
%TODO Write something here
\subsection{Projektfelépítés}
A dolgozat során elkészített prototípus alkalmazás (\textit{OrleansSpectral}) felépítése hasonló a 
tradicionális Orleans alkalmazásokhoz, rendelkezik a \ref{subs:orleansProjects}. szakaszban említett
3 komponenssel (\textit{Grains}, \textit{Grain interfaces}, \textit{Client}), valamint ezeken túl 
egy \textit{Common} projekttel, amely az egyes komponensek mindegyike
által használt osztályokat és mûveleteket tartalmazza.

\begin{figure}[ht!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=130mm]{figures/orleansSpectralComponents.png}
	\caption{Az alkalmazás komponensdiagramja \label{fig:orleansSpectralComponents}}
\end{figure}

\subsubsection{Az AEGIS keretrendszer integrációja}
Távérzékelt felvételek feldolgozásához szükség volt egy egységes téradatmodellre,
a felvételek beolvasására, a végrehajtandó mûveletekre, illetve az eredmények lemezre történõ kiírására.
Ennek megfelelõen az \textit{AEGIS} keretrendszer \textit{Core, IO}, valamint \textit{Operations} komponenseire volt
szükség, ezek kerültek integrálásra. Mivel mindkét rendszer a \textit{.NET} keretrendszerre épül, 
így az integráció is egyszerû volt, csupán az AEGIS által nyújtott \textit{.NET szerelvények} 
(\textit{assembly}) referálására volt szükség a fent felsorolt projektekben.

\subsection{Input adatok particionálása és feltöltése} %TODO Not the best section title
A \ref{ch:remoteSensingAnalysis}. fejezetben említésre került, hogy távérzékelt felvételek
elosztott feldolgozásánál az input adatokat valamilyen tulajdonság alapján feldarabolunk
és az egyes darabokat külön számítási egységekkel dolgozunk fel. Az Orleans rendszer
esetén is ez történt, azonban a particionálás mûvelete kiegészült egy 
\textit{partíció leíró} fájl generálásával, amely tartalmazza az eredeti kép dimenzióit,
az egyes darabok elhelyezkedését és kiterjedését az eredeti képhez képest, a fájlok fizikai elérési útvonalát,
valamint további metainformációkat (pl: a particionáláshoz használt algoritmus). 
Ezen felül a leíró fájl tartalmazza az 
eredeti kép \textit{hisztogram-értékei}t, ez az információ késõbb felhasználható az egyes mûveletekben.

Mivel a Hadoop \textit{HDFS} rendszerrel ellentétben az Orleans keretrendszer nem definiál saját elosztott
fájlrendszert, így a feldarabolt kép darabjainak szétosztása manuálisan történik a klaszterben. Az egyes darabokat
fel kell töltenünk a feldolgozó egységekre, és az elérési útvonalukat 
rögzítenünk kell a partíció-leíróba.

\subsection{Adatok feltérképezése, azonosítása és beolvasása}
Az adatok elhelyezése után az õket feldolgozó aktorok létrehozása következik.
A megfelelõ teljesítmény érdekében minden partíciót külön aktor fog feldolgozni,
ehhez szükséges tudnunk mely szerveren hány fájlpartíció helyezkedik el, és ezek mindegyikére
létrehozni egy aktor entitást.

Mint korábban említésre került, direkt módon nem határozhatjuk meg az aktorok elhelyezését a
klaszterben, azonban az elhelyezési stratégiát befolyásolhatjuk a \textit{Placement} attribútumokkal.
Sajnos jelenleg a rendszer nem tartalmaz olyan \textit{Placement} stratégiát, amellyel meghatározott mennyiségû
\textit{Grain}-t tudnánk létrehozni az összes szerveren (Az \textit{ActivationCountBasedPlacement} áll
legközelebb a feladathoz, azonban ez a stratégia fõként nagyobb klaszterek esetén tud hatékony lenni
a dolgozat során nem produkált használható teljesítményt).

\begin{figure}[h!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=110mm]{figures/getOneGrainFromEachSilo.png}
	\caption{Minden szerverrõl egy menedzser aktor aktiválása \label{fig:getOneGrainFromEachSilo}}
\end{figure}

A fenti limitációk megkerülése érdekében egy saját stratégia került alkalmazásra - bevezetünk egy
"\textit{manager}" aktort (\textit{OperationManagerGrain}), 
melyet a \textit{RandomPlacement} attribútummal látunk el. A \textit{manager} %TODO check if RandomPlacement is used
aktorból addig hozunk létre új aktivációkat, amíg a klaszter minden szerverén legalább egy létre nem jön
(alapértelmezés szerint az aktort hosztoló szerver identitása is transzparens az alkalmazás számára, 
azonban ez az információ a \textit{Grain}-ek identitásából visszafejthetõ)
Mivel a véletlenszerû elhelyezés közel normális eloszlású, és mivel az aktorok létrehozása nem költséges
mûvelet, így ez a fázis nem okoz teljesítményromlást a feldolgozásban. 
A létrehozott aktorok közül minden szerverrõl egyet választunk, ez lesz a szerver "menedzsere". 

\begin{figure}[h] %TODO Place and check if it can be seen correctly
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=150mm]{figures/grainsClassDiagram2.png}
	\caption{Az aktorok osztálydiagramja \label{fig:grainClassDiagram}}
\end{figure}


A menedzser entitás nem végez spektrális mûveleteket, hanem a mûveleteket feldolgozó aktorok 
példányosításáért és a kliensnek való továbbításáért felel. Egy elõkészítési fázisban
minden menedzser \textit{Grain} feltérképezi a szerverén lévõ feldolgozandó fájldarabokat
(a partíció leíróban megadott útvonalon), és ennek megfelelõ mennyiségû feldolgozó \textit{Grain}-t
(\textit{SpectralOperationGrain}) példányosít. A \textit{SpectralOperationGrain}-t a \textit{LocalPlacement}
attribútummal látjuk el, így minden új aktiváció az õt példányosító menedzser alkalmazás szerverén
fog létrejönni. A létrehozott \textit{Grain}-eket ezután hozzárendeljük a feltérképezett fájldarabokhoz.
Így szerver szinten minden entitásról tudjuk hogy melyik fájldarabot dolgozza fel. 

Azonban a megfelelõ
kommunikáció érdekében minden szerveren minden Grain-nek tudnia kell az összes fájldarabról, és annak
elérhetõségérõl. Ehhez minden menedzser továbbítja a szerveren lévõ feldolgozó \textit{Grain}-ek 
identitását és a hozzá tartozó fájldarabokat a kliensnek (erre egy dedikált \textit{Grain} is definiálható
lett volna, azonban a feldolgozó aktorokkal való direkt kommunikációhoz egyébként is szükséges
továbbítani az identitásukat a kliensnek). A kliens a korábban említett partíció leíróban kiegészíti
az összes fájldarabra vonatkozó információt a feldolgozó \textit{Grain}-ek identitásával. 
Ezután elküldi a kiegészített leíró fájlt ezeknek az aktoroknak.

%TODO Activity Diagram about merging association into one and propagating back to the worker actors

Az mûveleteket végzõ aktorok létrehozása és megfelelõ információval való ellátása után következik a 
kívánt mûvelet végrehajtása. A mûveletet valamint paramétereit az alkalmazás indításánál paraméterekként 
adhatjuk meg.

\section{Vizsgált algoritmusok}
Az elemzett algoritmusok megválasztásánál fontos szempont volt a sokszínûség - a távérzékelt felvételek 
feldolgozásának mindkét fázisából, mindegyik munkaterület-csoportból kerültek kiválasztásra
mûveletek, ezáltal átfogó képet kaphatunk, a képfeldolgozás mely részein alkalmazható hatékonyan a rendszer. 

%\subsection{Lokális mûveletek}
%\subsubsection{Spektrális Invertálás}
%\subsubsection{ToA-Reflektancia}
%
%\subsection{Fokális mûveletek}
%\subsubsection{Konstans küszöbölés}
%\subsubsection{Otsu küszöbölés}
%
%\subsection{Regionális mûveletek}
%\subsubsection{Negyedelõ fa alapú szegmentálás}
%\subsubsection{Szekvenciális csatolás alapú szegmentálás}
%\subsubsection{Legjobb összevonáson alapuló szegmentálás}
%
%\subsection{Globális mûveletek}
%\subsubsection{Kiegyensúlyozott hisztogram-küszöbölés}
%\subsubsection{Klaszterezés}

% ------------------------------------------------------------------------------

\chapter{Eredmények}


% ------------------------------------------------------------------------------

\chapter{Összegzés}

% ------------------------------------------------------------------------------


\cleardoublepage

\phantomsection

\addcontentsline{toc}{chapter}{Bibliography}

\begin{thebibliography}{9}
\bibitem{richards} Richards, J. A., Jia, X.: \textit{Remote Sensing Digital Image Analysis, An Introduction, fifth edition}, Springer, 2013, 978-3-642-30061-5.

\bibitem{remoteSensingLecture} László, I., Csornai, G., Fekete, I., Giachetta, R.: \textit{Távérzékelt felvételek elemzése}, Egyetemi jegyzet, Eötvös Loránd Tudományegyetem Informatikai Kar, Budapest, 2014.

\bibitem{aegis} Giachetta, R.: \textit{AEGIS - A state-of-the art component based spatio- temporal framework}, OSGeo Journal 13.1, pp. 68-77, 2014.

\bibitem{aegisHadoop} Giachetta, R., Fekete, I.: \textit{A case study of advancing remote sensing image analysis}, Acta Cybernetica, 22, pp. 57-79, 2015.

\bibitem{dotnetOrleans} \textit{Microsoft Orleans, A straightforward approach to building distributed, high-scale applications in .NET}, http://dotnet.github.io/orleans

\bibitem{orleansMSR} Philip A. Bernstein, Sergey Bykov, Alan Geller, Gabriel Kliot, Jorgen Thelin: \textit{Orleans: Distributed Virtual Actors for Programmability and Scalability}, Microsoft Research

\bibitem{mapAlgebra} \textit{Map Algebra: Global, Zonal, Focal and Local Operations}, http://gisgeography.com/map-algebra-global-zonal-focal-local/

\bibitem{distributedImageProcessing} Giloi, W. Distributed Image Processing. In \textit{Advances in Digital Image Processing}, pages 249-263. 1979.

\bibitem{mapReduce} Dean, J. and Ghemawat, S. \textit{MapReduce: Simplified Data Processing on Large Clusters}. 
		In \textit{Proceedings of the 6th Conference on Symposium on Opearting Systems Design \& Implementation}, volume 6 of \textit{OSDI?04}, pages 10-10, 2004.

\bibitem{spatialHadoop} Eldawy, A. and Mokbel, M. F. \textit{SpatialHadoop: An Efficient Mapreduce Framework for Spatial Data}. 
					Data Engineering (ICDE), 2015 IEEE 31st International Conference
					
\bibitem{hadoopGIS} Ablimit Aji , Fusheng Wang , Hoang Vo , Rubao Lee , Qiaoling Liu , Xiaodong Zhang , Joel Saltz, 
\textit{Hadoop GIS: a high performance spatial data warehousing system over mapreduce}, Proceedings of the VLDB Endowment, v.6 n.11, p.1009-1020, August 2013

\bibitem{actorOrig} Carl Hewitt, et al. \textit{Actor Induction and Meta-evaluation} Conference Record of ACM Symposium on Principles of Programming Languages, January 1974.

\bibitem{actorErlang} Vinoski, Steve: \textit{Concurrency with Erlang}. IEEE Internet Computing (2007), 11: 90-93

\bibitem{erlang} Armstrong, J.: \textit{Erlang}. CACM, 53, 9 (Sept. 2010), 68-75

\bibitem{actorScala} Philipp Haller, Martin Odersky, \textit{Scala Actors: Unifying thread-based and event-based programming}, Theoretical Computer Science, v.410 n.2-3, p.202-220, February, 2009

\bibitem{actorAkka} GUPTA, Munish. \textit{Akka essentials}. Packt Publishing Ltd, 2012.

\bibitem{sfa} Herring, J. \textit{OpenGIS Implementation Standard for Geographic information-Simple feature access-Part 1: Common architecture.} OGC Document 4.21 (2011): 122-127.

\end{thebibliography}

\end{document}
