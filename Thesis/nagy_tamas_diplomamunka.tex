\documentclass[a4paper,12pt]{report}


\usepackage[latin2]{inputenc} % vagy latin2 helyett utf8
\usepackage[T1]{fontenc}      % karakterkódolás
\usepackage[magyar]{babel}    % magyar beállítások
\frenchspacing                % helyközök
%\usepackage{times}           % betûtípus
\usepackage{lmodern}          %   vagy inkább ez

\usepackage[margin=2.5cm,left=3.5cm,includeheadfoot]{geometry}
                              % margók
\usepackage{graphicx}         % képekhez
\usepackage{grffile}
\usepackage{setspace}         % sorköz
\onehalfspacing               % másfeles

\usepackage{hyperref}		  % table of contents hyperlink
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{caption}

\usepackage{chngcntr}
\usepackage{siunitx}
\usepackage{float}

%\usepackage[nottoc,numbib]{tocbibind}

%\counterwithout{figure}{chapter}

\graphicspath {{figures/}}

\addto\captionsmagyar{ \renewcommand{\listfigurename}{Ábrajegyzék} }



\begin{document}

% ------------------------------------------------------------------------------
% Címlap

\input{cimlap.tex}

% ------------------------------------------------------------------------------
% Témabejelentõ

%\vspace*{\fill}

%\vfill
%\thispagestyle{empty}
%\newpage
%\setcounter{page}{1}

% ------------------------------------------------------------------------------
% Tartalomjegyzék

\tableofcontents

% ------------------------------------------------------------------------------


\chapter{Bevezetés}
Lorem ipsum...


% ------------------------------------------------------------------------------

\chapter{Távérzékelt felvételek elemzése} \label{ch:remoteSensingAnalysis}
A fejezet célja betekintést nyújtani távérzékelt felvételkiértékelés folyamatába.
Elsõként a távérzékelés fogalma, fizikai és technikai alapjai, valamint alkalmazási lehetõségei kerülnek ismertetésre.
Ezután a távérzékelt felvételek kiértékelésének célja, feldolgozási folyamata
és a folyamat során elvégzett mûveletek bemutatása következik.

\section{A Távérzékelés}
Távérzékelés alatt olyan adatgyûjtési és feldolgozási eljárásokat értünk, melynek során
tárgyakról vagy területekrõl közvetve, azok érintése nélkül gyûjtünk és rögzítünk adatokat.

Manapság a távérzékelést leggyakrabban földfelszíni-, illetve légköri adatok begyûjtésére értjük, valamilyen légi, vagy ûrbéli szenzor segítségével. 
Ezek a szenzorok a földfelszínrõl érkezõ energiát érzékelik, ez által alkotnak képet egy bizonyos területrõl. \cite{richards}

\subsection{A távérzékelés fizikai és technikai alapjai} \label{subs:remoteSensingBasics}
A távérzékelõ rendszereknek alapvetõen három fõ összetevõje van: A sugárforrás, a megfigyelés tárgyát képezõ földfelszín és az érzékelõ.

Az érzékelt energia forrása alapján beszélhetünk \textit{passzív}-, illetve \textit{aktív} távérzékelõ szenzorokról.
A \textit{passzív} szenzorok valamilyen természetes energia sugárzását érzékelik, ez lehet a Föld által kibocsátott, vagy
visszavert energia. \textit{Passzív} szenzorok által leggyakrabban használt energiaforrás a Napból érkezõ visszavert energia.
Az \textit{aktív} szenzorok abban különböznek passzív társaiktól, hogy õk maguk sugározzák a földfelszínre az érzékelni kívánt energiát.

\begin{figure}[h!]
	\centering
	\includegraphics[width=90mm]{figures/remote_sensing_components.jpg}
	\caption{A távérzékelési rendszer összetevõi \label{fig:remote_sensing_components}}
\end{figure}

A távérzékelt felvételek \textit{spektrális felbontás}a meghatározza, hogy az elektromágneses spektrumon belül mely
hullámsávokat milyen részletességgel vételezi a szenzor. Az úgynevezett \textit{pankromatikus} szenzorok egy spektrális
sávot felvételeznek, mely lefedi a teljes látható tartományt, valamint belenyúlhat a közeli infravörös tartományba.
A \textit{multispektrális} szenzorok több különbözõ elektromágneses hullámsávban érzékelnek. A leggyakrabban használt
\textit{multispektrális} szenzorok sávszáma 3 és 7 között van, és a reflektív tartomány mellett 
a termális infravörös sávot is felvételezik.

Az érzékelõ a megadott hullámsávban beérkezõ mennyiséget digitális értékekké (\textit{Digital Number - DN})
alakítja - az érzékelõk \textit{radiometriai felbontása} 
a kvantálás finomságát jelzi. Minél több energiaszintet képes megkülönböztetni az szenzor, annál magasabb
radiometriai felbontással rendelkezik. A legelterjedtebb nagyfelbontású multispektrális szenzoroknál 
a \textit{7-8 bites felbontás} jellemzõ, mely \textit{128}, illetve \textit{256} különbözõ intenzitásszintnek felel meg.

Egy többsávos digitális felvételezés eredménye egy olyan mátrixként értelmezhetõ, melynek minden eleme egy elemi
felszíndarabnak felel meg - a mátrix elemeinek pozíciója kapcsolatban van a felvételezett felszíndarab földrajzi
helyzetével. Az egyes mátrixértékek maguk is vektorok, melyek elemei a megadott felszíndarabon belül az egyes
spektrális sávokban mért intenzitásértékeket tartalmazzák. Egy \textit{N} sorból és \textit{M} oszlopból álló
többsávos digitális felvétel az alábbi formulában írható le:

\begin{center}
$
V = 
\begin{pmatrix}
\vec{v}_{11} & \cdots & \vec{v}_{1\textit{M}} \\
\vdots  & \ddots & \vdots  \\
\vec{v}_{\textit{N}1} & \cdots & \vec{v}_{\textit{NM}} 
\end{pmatrix}
$,
\end{center}

ahol B számú spektrális sávot feltételezve $\vec{v}_{\textit{ij}} = (v_{\textit{ij}1}, \hdots, v_{\textit{ijB}})$
az egyes elemekhez tartozó intenzitásértékek vektora. A vektor egyes elemei mindegyik spektrális sávban (kvantált formában)
megadják az adott intenzitásértéket, tehát: $v_{\textit{ijb}} \in [\textit{1}\hdots\textit{H}]$, ahol \textit{H} a
radiometriai felbontás alapján ábrázolható maximális értéket jelöli.

A mátrix elemeinek koordinátáit és értékeit annak megfelelõen értelmezzük,
amelyet az elvégezni kívánt mûvelet megkövetel. \cite{remoteSensingLecture}

\subsection{Távérzékelt felvételek alkalmazási területei}
Az élet számos területén felhasználhatóak a távérzékeléssel nyert információk, például:
\begin{itemize}
	\item \textbf{Katasztrófavédelem} 
	\newline 
	Hurrikánok, földrengések, erózió, árvíz megfigyelése. A távérzékelt adatokat felhasználhatjuk a
	természeti katasztrófa hatásainak kiértékelésére, az információ alapján megelõzõ lépéseket tehetünk a jelenlegi helyzet kezelésére, valamint a jövõbeni katasztrófákra is felkészülhetünk.
	
	\item \textbf{Természeti erõforrások monitorozása }
	\newline
	Földhasználat, vadvilági területek monitorozása. A távérzékelt adatok felhasználásával minimalizálhatjuk a
	városi növekedés káros hatásait a környezetre, valamint dönthetünk, hogyan védhetjük természeti erõforrásainkat.

	\item \textbf{Mezõgazdasági termés,- illetve hozambecslés }
	\newline
	A távérzékelt adatok segítségével becslést adhatunk a monitorozott termõterület hozamára, illetve megelõzhetjük
	a termést veszélyeztetõ növények és állatok kártételét.
\end{itemize}

A felhasználási területek közül fõként a katasztrófavédelemnél kiemelten fontos, hogy az érzékelés pillanatától számítva 
mennyi késéssel juthatunk hozzá a kiértékelt adatokhoz - árvíz esetén például órák alatt változhat a vízszint, amelyrõl ha idõben
értesülünk, megtehetjük a megfelelõ óvintézkedéseket, késlekedés esetén azonban jelentõs károk keletkezhetnek. A mûholdak visszatérési
ideje csupán egy tényezõ az eredmény elõállításának gyorsaságában - kritikus lehet a meglévõ adatok kiértékelésének sebessége is.

\section{Távérzékelt felvételek feldolgozása}
A távérzékelés általánosságban a \textit{felvételezés}tõl a \textit{tematikus információ-kivonás}ig tart. 
A felvételezés során a szenzorra beérkezõ intenzitásértékek nem tükrözik hûen a földfelszín sugárzását, 
így elsõ lépésként a felvételeket egy elõfeldolgozó fázisban korrigálni kell.
Ezután a felvételek tematikus kiértékelése következik, mely történhet 
manuálisan vagy automatizáltan, esetleg a kettõ keverékeként. A tematikus kiértékelés módja befolyással lehet arra,
mely elõfeldolgozó mûveletek végrehajtása szükséges.

\subsection{Elõfeldolgozás} \label{ssn:preProcessing}
A mûholdak által szolgáltatott nyers digitális értékek számos hibaforrással lehetnek terheltek, melyek korrigáció nélküli
felhasználása hibás kiértékelést eredményez.
Ide tartoznak például a \textit{légköri zavaró hatások} (páratartalom, hõmérséklet-különbségek), a felvevõ rendszer és
hordozóeszközének mozgási szabálytalanságaiból adódó \textit{torzítás}ok, valamint a szomszédos területekrõl való \textit{átsugárzás}.
A hibaforrások kiküszöbölése mellett a hatékony feldolgozás érdekében érdemes minden felvételt egységes geometriai rendszerbe transzformálva
kezelni, ezt a mûveletet \textit{geometriai korrekció}nak nevezünk.

\textit{Intenzitás-korrekció} alatt azokat a mûveleteket értjük, melyekkel a felvétel képpontjaihoz és az egyes spektrális 
sávokhoz tartozó sávonkénti intenzitást módosítjuk. A ténylegesen végrehajtandó intenzitás-mûveleteket nagyban befolyásolja
a felhasználás célja, mivel az emberi szem és agy más szempontok alapján képes különbséget tenni a felvételen látható
felszínborítások között, mint a kvantitatív számítógépes mûveletek.

Az intenzitás-korrekció csoportjába tartozik például a \textit{radiometriai korrekció}, valamint a különbözõ látványjavító mûveletek.
A \textit{radiometriai korrekció} arra szolgál, hogy a szenzor által mért digitális számértékekbõl megkapjuk
a földfelszín fizikai paramétereit. A rendelkezésre álló korrekciós adatok és a feldolgozás igénye meghatározza,
hogy milyen szintû korrekcióra van szükség:

\begin{itemize}
	\item A \textit{spektrális radiancia} a szenzorra érkezõ elektromágneses sugárzás intenzitása, 
		mely a digitális értékekkel	legtöbbször lineáris kapcsolatban áll. 
		A leíró függvény paraméterei a szenzorok korától és beállításaitól függõen 
		változhatnak, így a felvételek elengedhetetlen paraméterei.
		
	\item A \textit{ToA-Reflektancia} (\textit{Top of Atmosphere Reflectance} - \textit{légkör tetején mérhetõ reflektancia}), 
		a felszín visszaverésének olyan közelítése, mely nem veszi figyelembe a sugárzás és a légkör közötti kölcsönhatást.
		A reflektancia a radianciából számítható, figyelembe véve a \textit{Nap}, a \textit{felvételezett terület} 
		és a \textit{szenzor} geometriai viszonyát egymáshoz képest, 
		valamint az \textit{irradianciát} (a beesõ napsugárzás intenzitása)
		
	\item A \textit{felszíni reflektancia} a ToA-reflektanciából számítható a légköri korrekció végrehajtásával,
		tehát az olyan kölcsönhatások eliminálásával, amelyek a sugárzásra a légkörben történõ áthaladása során hatnak
		(például \textit{ózon}, \textit{szén-dioxid} és a \textit{vízpára}).
	
\end{itemize}

Az egyes \textit{látványjavító mûveletek} célja a felvétel vizuális megjelenítési tulajdonságainak megváltoztatása az emberi szemmel történõ
értelmezés könnyítése érdekében. Látványjavító mûvelet például az \textit{invertálás}, valamint a különbözõ \textit{szûrések} A 
látványjavító mûveletek egy részében (pl.: szûrések) ténylegesen megváltoznak a pixelértékek, ebben az esetben 
a javítás után már nem végezhetõ el a numerikus kiértékelés, mivel elveszítjük a földfelszín konkrét
fizikai paramétereit.\cite{remoteSensingLecture}

\subsection{Tematikus osztályozás}
A felvételkiértékelés célja a felszínborítás, földfelszíni objektumok fizikai jellemzõinek megállapítása. A felvételkiértékelés két alapvetõ módszere a 
\textit{vizuális interpretáció} és a \textit{kvantitatív, numerikus kiértékelés}. 

A vizuális interpretáció során a tematikus döntéseket a felvételen \textit{látható} információ alapján hozza meg a
kiértékelõ személy - ez olyan esetekben hatékony eljárás, amikor \textit{geometriai összefüggések}, 
\textit{struktúrák} felismerésére van szükség, melyet a számítógép nem képes azonosítani.

Numerikus kiértékelés esetén a tematikus döntések meghozatala a számítógépen, 
elõre megadott feltételek alapján történik. A számítógépes feldolgozás elõnye, hogy nagy mennyiségû
adat feldolgozására is alkalmas, illetve az egyes textúrák közötti tónuskülönbségek mérésében és elkülönítésében
is jobban teljesít, mint az emberi szem és agy rendszere. Mivel mindkét módszer rendelkezik jelentõs elõnyökkel
a másikkal szemben, gyakran együttesen kerülnek alkalmazásra. 

A \textit{tematikus osztályozás} egy kvantitatív kiértékelési mód, melynek célja egy olyan tematikus térkép
elkészítése, mely véges számú célosztállyal írja le a vizsgált területet. A tematikus térkép minden pixeléhez a
célosztály egy értéke tartozik. A tematikus osztályozási módszerek lehetnek \textit{pontonkénti mûvelet}ek, valamint \textit{szegmensenkénti mûvelet}ek.

A pontonkénti mûveletek minden egyes képpontra külön meghatározzák a tartalmazó célosztályt, így figyelmen 
kívül hagyják a homogén területek szomszédos képpontjainak azonosságát. 
Pontonkénti mûveletek például az egyes \textit{küszöbölõ eljárás}ok, melyek során az spektrális intenzitás intervallumot
egy vagy több különbözõ részre vágjuk, ezek a részek fogják alkotni a célosztályokat. A pixelek spektrális intenzitása
meghatározza hogy melyik részintervallumba, és ez által melyik célosztályba kerülnek. A vágási pont(ok) meghatározása
történhet manuálisan (pl.: \textit{konstans küszöbölés}), valamint automatikusan a kép valamilyen tulajdonsága 
(legtöbbször a \textit{hisztogram}) alapján.

A \textit{szegmensenkénti mûvelet}ek, homogén területek sorozatán képesek elvégezni az osztályozást. 
Ezen homogén területek feltárásának és összekapcsolásának módja a \textit{szegmentálás}.
A szegmentálás eredményeként egy olyan tematikus térképet kapunk, mely minden képpontra megadja a pontot 
tartalmazó szegmens sorszámát. Az eredményszegmensek a legtöbb esetben nem feleltethetõek meg egyértelmûen az
elérni kívánt célosztályoknak, számuk jellemzõen nagyságrendekkel nagyobb. 
Az összetartozó szegmensek összevonása és ezáltal célosztályokká redukálása a \textit{klaszterezõ} eljárások feladata.

%TODO Placement
\begin{figure}[h!]
	\centering
	\captionsetup{width=1\textwidth, justification=centering}
	\includegraphics[width=110mm]{figures/coordinateSystem.jpg}
	\caption{Felszíndarabok sugárzása  $x_1=0.5\si{\micro\metre}$ 
		és $x_2=0.9\si{\micro\metre}$ hullámhosszon \label{fig:intensitySpaces}}
\end{figure}

A klaszterezõ mûveletek a szegmensek \textit{intenzitástér}ben való elhelyezkedése alapján 
határolják be az egyes elemeket a megfelelõ osztályokba. Az intenzitástérben a kép egy pixelének sávonkénti
intenzitásértékei adják a pont koordinátáit. A \ref{fig:intensitySpaces}. ábrán látható, hogy az egyes intenzitásértékek
jellemzõen nem pontokba tömörülnek, hanem rendelkeznek bizonyos mértékû szórással. A klaszterezés során
ezen térben keressük az összetartozó elemeket, és ez alapján alakítjuk ki a végsõ osztályhalmazokat.\cite{remoteSensingLecture}

\subsection{Feldolgozó mûveletek munkaterülete}
A feldolgozó mûveletek munkaterülete azt határozza meg, hogy egy lépés végrehajtásához mekkora adathalmazra
van szükség. Ez alapján négy csoportot különböztetünk meg

\begin{itemize}
	\item \textit{Lokális mûvelet:} A forrás egy megadott képpontjából a cél egy képpontját állítja elõ,
	lényegében egy pontból pontba történõ transzformáció. Ebbe a csoportba tartoznak az egyszerûbb képi
	transzformációk, mint az \textit{invertálás}, valamint az egyes \textit{küszöbölõ} algoritmusok.
	\item \textit{Fokális mûvelet:} Egy megadott képpont kiszámításához annak valamilyen sugarú környezetében lévõ
	értékek felhasználásával dolgozik. Ide tartoznak például a különbözõ \textit{szûrõ} mûveletek.
\end{itemize}

\begin{figure}[h!]
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/localOperation.png}
	{\caption{Lokális mûvelet\cite{mapAlgebra}}}\label{fig:localOperation}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/focalOperation.png}
	\caption{Fokális mûvelet\cite{mapAlgebra}}\label{fig:focalOperation}
	\endminipage\hfill
\end{figure}

\begin{itemize}
	\item \textit{Regionális (zonális) mûvelet:} %TODO Recompose
	A regionális mûveletek hasonlóak a fokális mûveletekhez, leszámítva hogy míg a fokális mûveletnél 
	a képpont kiszámításához szükséges környezet egy elõre definiált
	méretû terület, addig a zonális mûveletnél a szükséges környezet az õt tartalmazó régió (zóna), 
	mely a feldolgozás során dinamikusan változhat. Regionális mûvelet például a legtöbb \textit{szegmentáló}
	algoritmus
	
	\item \textit{Globális mûvelet:} Az eredménykép minden képpontjának elõállításához rendelkeznie kell a teljes
	forráskép ismeretével. Ide tartoznak például azok a \textit{küszöbölõ eljárások}, melyek
	a küszöbértéket a teljes képbõl számított valamilyen statisztika (pl.: hisztogram) alapján határozzák meg. 
	A legtöbb \textit{klaszterezõ algoritmus} is ebbe a kategóriába tartozik, mivel a klaszterek
	kialakítása	során a képpont fizikai elhelyezkedését már nem vesszük figyelembe, csupán a multispektrális térben lévõ pozícióját.
\end{itemize}

\begin{figure}[h!]
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/zonalOperation.png}
	{\caption{Regionális mûvelet\cite{mapAlgebra}}}\label{fig:zonalOperation}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{figures/globalOperation.png}
	\caption{Globális mûvelet\cite{mapAlgebra}}\label{fig:globalOperation}
	\endminipage\hfill
\end{figure}

A mûveletek ezen tulajdonsága kulcsfontosságú az elosztott feldolgozás témakörében - lokális mûveletek esetén 
a feldolgozandó adat könnyedén particionálható, a feldolgozás pedig tetszõleges számú párhuzamos szálon futtatható.

Fokális mûveleteknél biztosítanunk kell, hogy az egyes képpontok mindegyike rendelkezzen információval a környezetérõl
- ezt megtehetjük például a partíciókra bevezetett \textit{átfedés} definiálásával, központi
\textit{utófeldolgozás}sal, illetve ha lehetõségünk van az egyes partíciókon futó folyamatok közvetlen 
kommunikációjára, a szükséges pixelértéket elkérhetjük a vele rendelkezõ folyamattól.

Regionális mûveletek esetén a fokális mûveletekhez hasonlóan biztosítanunk kell a környezõ értékek elérését. Itt 
jellemzõen az átfedéses megoldás nem célravezetõ, tekintve hogy nincs információnk a folyamat elindításának
pillanatában, mekkora területre lesz szükség az egyes képpontok kiszámításához, ez az információ a mûvelet futása alatt
dinamikusan változhat.

Sok esetben globális mûveletek is elvégezhetõk particionált módon, itt azonban mindenképp szükséges egy központi
összefuttató lépés - ennek módszere az alkalmazott mûvelettõl függ.\cite{remoteSensingLecture}

\section{Adatkezelés}
Az alkalmazási területeknél már említésre került, hogy a feldolgozási idõ kritikus lehet az adatkiértékelés szempontjából.
Ezt nehezíti az a tény, hogy a kiértékelõ eljárások többsége meglehetõsen komplex, illetve hogy gyakran hatalmas mennyiségû
adathalmazzal kell dolgoznunk.
Ez felveti olyan megoldások kutatásának szükségességét, amellyel a kiértékelés ideje csökkenthetõ.

A legkézenfekvõbb lehetõség a feldolgozó egységek \textit{számítási kapacitás}ának megnövelése. Erõsebb \textit{processzor}, 
több \textit{memória}, I/O mûveletek gyorsabb elvégzésére alkalmas \textit{háttértár}ak
beszerzése esetén a számítási teljesítményünk is növekszik. A megoldás legnagyobb elõnye, hogy a meglévõ algoritmusok a megnövelt 
teljesítményû környezetben is felhasználhatóak, a feldolgozás szoftveres része nem igényel adaptációt. Azonban a
rendszer teljesítménynövelésének ezen módja költséges, és a fejlesztéssel nyert számítási kapacitás aránya egy bizonyos szint után csökken.

A teljesítménynövelés másik lehetséges módja az évek óta kutatott\cite{distributedImageProcessing}, és a számítási
felhõk elterjedésével az utóbbi idõben leginkább teret nyert \textit{elosztott feldolgozás}.

\begin{figure}[h!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=80mm]{figures/imagePartitioning_withOverlap.png}
	\caption{Input kép feldarabolása \textit{átfedés}ek alkalmazásával \label{fig:imagePartitioning}}
\end{figure}

Távérzékelt felvételek elosztott feldolgozása úgy történik, hogy a feldolgozandó kép alkotó elemeit valamilyen tulajdonság alapján 
(pixel értékek, spektrális intenzitásértékek) \textit{feldarabolunk} (\textit{particionálás}), az egyes feldolgozó egységek pedig ezen darabokat dolgozzák fel.
Ekkor - a mûvelet korábban ismertetett munkaterületének megfelelõen - a feldolgozó egységeknek szükségük lehet olyan információkra, melyek
a teljes adat egy részének vagy egészének ismeretében számíthatók csak ki. 
Egyszerûbb esetben ezt megoldhatjuk \textit{átfedések} alkalmazásával - az input adatot úgy particionáljuk,
hogy az eredetileg neki szánt területnél valamennyivel nagyobb területet tartalmazzon. 
Ez fõként fokális mûveleteknél hasznos, ahol a pixelek kiszámítása egy meghatározott sugarú környezet
pixelértékeinek felhasználásával történik. Ekkor az átfedések segítségével akár más partíció felhasználása 
nélkül is kiszámítható az eredmény.

Regionális esetben is felhasználhatóak az átfedett területek, azonban az egyes régiók méretének
dinamikus változása miatt kisebb valószínûséggel lesz elég az átfedések által tartalmazott adat.
Emiatt szükséges lehet a feldolgozó egységeknek egymással kommunikálniuk feldolgozás közben,
hogy biztosíthassák a számításokhoz szükséges adatokat. Ezen adatok gyors és hatékony 
rendelkezésre állása kulcsfontosságú egy elosztott rendszer teljesítményében.

% ------------------------------------------------------------------------------

\chapter{Elosztott alkalmazások fejlesztése}
A fejezetben bemutatásra kerülnek a fõbb elosztott szoftverrendszerek elméleti alapjai, ezek néhány megvalósítása, valamint
távérzékelt felvételek feldolgozásában lévõ alkalmazási lehetõségeik, külön részletezve a dolgozat
témáját, a \textit{Microsoft Orleans} platformot.

Az \textit{elosztott rendszerek} olyan szoftverrendszerek, melyek komponensei fizikailag elkülönítve futnak, és futás során
egymással hálózaton keresztül kommunikálnak. A komponensek saját processzorral és memóriával rendelkeznek (Szemben a párhuzamos
rendszerekkel, amelyek a memóriát megosztják egymással).

Az elosztott architektúra több jelentõs elõnnyel is rendelkezik az egy számítási egységgel rendelkezõ rendszerrel szemben:
\textit{skálázhatóság} (a folyamat áteresztõképességének növelésének képessége), nagyobb \textit{hibatûrés}, 
hatékony \textit{terheléselosztás}, olcsó \textit{bõvíthetõség}.
Az elosztott feldolgozás hátránya a \textit{komplexitás}ában nyilvánul meg - 
az egyes komponensek egymással való \textit{hálózati kommunikáció}ját 
biztosítani kell, a kommunikációból adódó késést figyelembe kell venni, illetve kezelni kell a fellépõ \textit{konkurenciá}t.
A hibaelhárítás, valamint a diagnosztizálás is sokkal bonyolultabbá válhat egy elosztott rendszerben.

Ezen tényezõk indokolták olyan \textit{keretrendszerek} és \textit{architekturális koncepciók} kutatását, 
melyek az elosztott alkalmazások fejlesztésének nehézségeire részben vagy egészben megoldást nyújtanak.
A következõ részekben ezen koncepciók és néhány megvalósításuk kerül bemutatásra.

\section{MapReduce}
A \textit{MapReduce} nagy adathalmazok generálására és feldolgozására fejlesztett számítási modell.\cite{mapReduce}
Egy MapReduce alkalmazás alkotóelemei \textit{Map} és \textit{Reduce} funkciók. A \textit{Map} funkció az input
elemeibõl köztes \textit{kulcs/érték párok}at állít elõ, a \textit{Reduce} mûvelet pedig összevonja az összes olyan
köztes elemet, melynek kulcsa megegyezik.
A MapReduce paradigma alapján írt programok automatikusan párhuzamosíthatók, és skálázhatók. 
A futtatókörnyezet végzi az adatok \textit{particionálás}át, vezérli a végrehajtást, kezeli a 
\textit{gépek közötti kommunikáció}t és a fellépõ hibákat.
Ezzel lehetõséget nyújt elosztott környezetek erõforrásainak kihasználására anélkül, hogy a fejlesztõktõl 
komoly szaktudást követelne a párhuzamos és elosztott alkalmazásfejlesztés területén.

\begin{figure}[h!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=120mm]{figures/mapReduce.jpg}
	\caption{A \textit{MapReduce} folyamat \label{fig:mapReduceProcess}}
\end{figure}

\subsection{Hadoop}
A MapReduce modell egy implementációja az \textit{Apache Software Foundation} által fejlesztett 
\textit{Hadoop} keretrendszer. A rendszer komponenseinek tervezésénél a fõ szempont a hibatûrés volt - 
bármilyen hardveres hiba elõfordulása természetes, és a keretrendszernek automatikusan kezelnie kell.

A rendszer három fõ komponensbõl áll: A \textit{Hadoop Elosztott Fájlrendszer}bõl 
(\textit{HDFS - Hadoop Distributed File System}), a \textit{Hadoop MapReduce} adatfeldolgozóból, valamint
a \textit{Hadoop YARN}-ból, mely a rendszer erõforrás-kezelõje.
A Hadoop a fájlokat blokkokra osztja, és szétosztja az egyes \textit{node}-ok között. Az adatok feldolgozása
során a Hadoop a feldolgozó szoftvert tölti fel minden \textit{node}-ra, így az adatok helyben kerülnek
feldolgozásra (\textit{adatlokalitás}).

\subsubsection{Térinformatikai alkalmazása}
A Hadoop keretrendszer fejlesztésekor az alkalmazás fõ célterülete szöveges adatok feldolgozása volt.
A rendszer terjedésével azonban megjelent az igény az informatika több különbözõ területén való
alkalmazására. Ennek megfelelõen megjelentek a keretrendszer térinformatikai kiterjesztései is
\cite{spatialHadoop,hadoopGIS}, melyek
támogatják téradatok tárolását, indexelését, és \textit{MapReduce} alapú feldolgozását.
Az egyes feldolgozó mûveletek közül a lokális, illetve a fokális mûveletek könnyedén alkalmazhatók
egyszerû \textit{Map} függvényekként, regionális és globális esetben általában szükséges egy olyan
alternatív algoritmus bevezetése, amely az eredeti algoritmus kiegészítése egy (vagy több) 
\textit{Reduce} lépéssel.

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm]{figures/histogram_map_reduce.jpg}
	\caption{Hisztogramkiegyenlítés \textit{MapReduce} alkalmazásával \cite{aegisHadoop}
		\label{fig:histogram_map_reduce}}
\end{figure}

Például a \textit{hisztogram kiegyenlítés} mûvelet egy globális mûvelet, melynek szüksége van az egész képre vonatkozó
hisztogram értékekre. Ekkor Hadoop architektúrán a mûvelet három különbözõ lépésbõl áll. Elõször egy \textit{Map}
függvényben kiszámítjuk az egyes hisztogram értékeket minden fájldarabra. A második, \textit{Reduce} lépés
összefésüli ezeket az értékeket, és elõállítja a teljes hisztogramot. A harmadik lépésben pedig egy újabb \textit{Map}
utasítás alkalmazza a hisztogramkiegyenlítést a kiszámított teljes hisztogramértékek alapján.

Összességében elmondható\cite{aegisHadoop}, hogy a legtöbb esetben a mûveletek könnyedén adaptálhatók Hadoop környezetbe, 
azonban néhány alkalommal komplex módosításokra van szükség, és a portolt algoritmus helyfoglalási idénye sokkal nagyobb
lehet, mint az eredeti mûveleté. Ezen tényezõk indokolták további alternatív feldolgozó mechanizmusok kutatásának szükségét.

\section{Aktor modell} %TODO Extend if possible
Az \textit{Aktor modell} egy olyan konkurens matematikai modell, melynek alapegységei az "\textit{aktorok}" \cite{actorOrig}.
Az aktorok egymástól izolált egységek, melyek direkt módon, aszinkron \textit{immutable} üzeneteken keresztül kommunikálnak egymással.
Minden aktor rendelkezik egy "postaládával", ahová az üzenetek érkeznek, ezeket az üzeneteket dolgozza fel sorban 
- számítást végezhet, aktorokat hozhat létre, 
további üzeneteket küldhet, valamint beállíthatja, hogyan fog reagálni a következõ üzenetre.
Az üzenetek sorrendje nem garantált, de követelmény, hogy minden üzenet beérkezzen.

\begin{figure}[H]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=120mm]{figures/actorModel.png}
	\caption{Az \textit{aktor modell}.\label{fig:actorModel}}
\end{figure}

Az aktorok jellemzõen egy számítási szállal rendelkeznek, és nem osztanak meg memóriát egymás között. 
Ez eliminálja a versenyhelyzetek kezelésének szükségességét aktor szinten. 
A fejlesztõknek nem szükséges \textit{lock}olást, \textit{mutex}eket és más versenyhelyzet-kezelõ megoldásokat
alkalmazniuk, melyek nem tartoznak az alkalmazás logikájához. Az aktorok dinamikusan jönnek létre
a rendelkezésre álló erõforrások alapján, ezáltal hatékony terheléselosztás alkalmazható.

Az aktor modell akkor alkalmazható hatékonyan, ha az aktorok "könnyûsúlyúak", gyorsan példányosíthatók,
és folyamatuk nincs a rendszermag szálaihoz kötve, attól eltérõen ütemezhetõ.

\subsubsection{Aktor implementációk}
A modellt elõször az \textit{Erlang} programozási nyelvben alkalmazták konkurens alkalmazások fejlesztésére \cite{actorErlang}, majd a modell népszerûségének 
növekedésével több nyelv és keretrendszer is sikeresen 
adaptálta a modellt, pl.: a \textit{Scala} \cite{actorScala}, 
vagy az \textit{Akka} keretrendszer\cite{actorAkka}.

Ezek az aktor modell implementációk - jóllehet hatékony megoldást adnak az elosztott 
alkalmazásfejlesztésre - több elosztott rendszerrel kapcsolatos probléma kezelését a 
fejlesztõkre bízzák. A fejlesztõknek kezelniük kell az aktorok életciklusát (hiba esetén történõ leállás esetén az aktorok újraaktiválását), a rendszerben
történõ elhelyezését, valamint versenyhelyzetek kezelését. Ezek a limitációk, és a 
kiküszöbölésükre való törekvés hívta életre a \textit{Microsoft Orleans} keretrendszert.


\section{A Microsoft Orleans platform}
Az \textit{Orleans} egy - a \textit{Microsoft Research} által fejlesztett - keretrendszer, 
mely lehetõséget ad megbízható és skálázható felhõalapú alkalmazások fejlesztésére.

Az Orleans programozási modellje (\textit{Virtual Actor Model - Virtuális Aktor Modell})
az aktor modell egy olyan kiterjesztése, amely az aktorokat virtuális entitásokként kezeli, mely eliminálja a 
az elosztott erõforráskezelés és a megbízhatóság alkalmazás szinten történõ kezelését, megszünteti a konkurenciát, ezáltal
nem követel komplex tudást a fejlesztõktõl az elosztott alkalmazásfejlesztés területén.

A keretrendszert a \textit{Microsoft Windows Azure} számítási \textit{felhõben} több jelenleg is futó projekten 
hatékonyan alkalmazták, 2015 januárjában pedig nyílt forráskódú licenccel a nyilvánosság elé tárták.

\subsection{Virtuális Aktor modell}
Az Orleans rendszer egy módosított Aktor modellt definiál, amelyet elosztott alkalmazások, valamint az
Erlang nyelv Aktor modellének implementációja ihletett, és teljes egészében a .NET keretrendszerre épül.
Az Orleans aktorok (\textit{Grain}, szabad fordításban \textit{szemcse, gabonaszem}) a rendszer legkisebb
számítási alapegységei. Egy aktor enkapszulálja az állapotát és a viselkedését, és nem
oszt meg memóriát más aktorokkal, így két aktor között az egyetlen kommunikációs mód az aszinkron üzenetküldés.

Az aktorok az Orleans rendszerben a tradicionális modelltõl eltérõen virtuálisak. 
Egy aktor elméletben mindig létezik, nem hozható létre és nem semmisíthetõ
meg manuálisan. Az aktorok létezése nem függ a példányok számától, és nem függ futtató szerver állapotától.
Mivel az aktorok mindig léteznek, ezért mindig elérhetõek.
Az Orleans futtatókörnyezet automatikusan kezeli az aktorok példányosítását (\textit{aktiváció}) és megsemmisítését. 
Az alkalmazás futása során minden idõpillanatban egy aktor 0, 1 vagy több aktivációval rendelkezik.
Ha egy üzenet érkezik egy aktornak, és nincs egyetlen aktivációja sem, a rendszer létrehoz egy példányt az egyik elérhetõ 
szerveren (\textit{Orleans Silo}), valamint ha a példány egy bizonyos ideig kihasználatlanul marad, 
a futtatókörnyezet elvégzi a példány deaktiválását és felszabadítását. Ha egy szerver hiba miatt leáll, az 
Orleans egy másik elérhetõ szerveren automatikusan újrapéldányosítja azokat az aktorokat, 
amelyek a hibás szerveren futottak, és a nekik küldött üzeneteket erre az új szerverre irányítja.
Az alkalmazásoknak így nincs szükségük különbözõ \textit{életciklus felügyelet}i logika bevezetésére
(pl.: \textit{felügyeleti fák} az Erlang nyelvben \cite{erlang}).
Az aktorok automatikus példányosítása és életciklus-kezelése azt is eredményezi, 
hogy az aktorok fizikai elhelyezkedésérõl a futó alkalmazásnak nincs tudomása - 
egy bizonyos idõpillanatban egy aktornak akár 0 vagy egynél több aktivációja is lehet, ezt a 
keretrendszer tartja nyilván.

Jelenleg az Orleans rendszer kétféle aktivációs módot támogat: az \textit{állapot}tal rendelkezõ aktorok
egyszerre maximum egy aktivációval rendelkezhetnek, míg az \textit{állapotmentes} (\textit{Stateless Worker})
aktoroknak szimultán több egymástól független aktivációja is megengedett a klaszterben.

\subsubsection{Aktorok kommunikációja}
Az egyes aktorok azokon a metódusokon keresztül tudnak kommunikálni egymással, 
melyek az aktor interfészében definiálásra kerültek. Az összes metódus amelyet az interfészen
definiáltak, aszinkron (\textit{Task} visszatérési értékû) kell, hogy legyen.

Ahhoz, hogy egy aktor üzenetet küldhessen egy másik aktornak, szükséges \textit{referenciá}val
rendelkeznie a másik aktorra. Ezek a referenciák virtuálisak abban a tekintetben, hogy nem 
szolgálnak semmilyen információval a referált aktor fizikai elhelyezkedésérõl. 
A kommunikáció egy lokális \textit{proxy objektum}on keresztül történik, és az üzenetet
a futtatókörnyezet továbbítja a tényleges aktornak.

Az egyes üzenetek szerializálva kerülnek továbbításra - a beépített .NET [Serializable]
attribútummal ellátott objektumok is használhatók és az Orleans keretrendszer is rendelkezik
beépített szerializálóval, amely képes tömbök, illetve generikus objektumok 
szerializálására is, mindezek mellett pedig megtartja az objektumok identitását 
(ha két pointer ugyanarra az objektumra mutat, akkor deszerializálás után 
is ugyanarra az objektumra fognak mutatni).

\subsubsection{Elosztottság, Fordulók} 
Az aktorok minden aktivációja egyszálú, és \textit{fordulók}nak nevezett részletekben dolgoznak.
Az Orleans rendszer különbözõ aktivációk fordulóit futtathatja párhuzamosan, azonban minden
aktiváció csupán egy fordulót dolgoz fel egyszerre.
Ennek eredményeként aktor szinten nem jelenik meg párhuzamosság a rendszerben.
A forduló alapú modell ugyan megengedi több kérés fordulóinak átfedését 
(pl.: Amíg az egyik forduló egy \textit{I/O mûvelet} befejeztére vár,
egy másik forduló feldolgozása is elkezdõdhet), azonban ezt az Orleans rendszer
alapértelmezetten nem engedélyezi. Ez a viselkedés felüldefiniálható, és a fordulók
átfedhetnek, ha az aktor osztályt megjelöljük a [Reentrant] attribútummal.

\subsection{A keretrendszer implementációja}
Az Orleans rendszer szerverek egy csoportján fut, és három fõ alrendszere van - 
\textit{Üzenetküldés}, \textit{Végrehajtás} valamint \textit{Futtatókörnyezet}.

Az üzenetküldés alrendszer minden szervert egyszerû TCP kapcsolattal köt össze, 
és több kommunikációs szálon keresztül továbbítja az egyes üzeneteket.

A környezet alrendszer dönt az aktivációk elhelyezésérõl a klaszterben, a
végrehajtás pedig a rendelkezésre álló számítási szálak alapján futtatja az
aktorok kódját.

Amikor egy aktor egy másik aktort hív, a Végrehajtás a függvényhívást üzenetté
konvertálja, és átadja az üzenetküldésnek a cél aktor identitásával együtt.
Az üzenetküldés lekéri a környezettõl, hogy melyik szerver hosztolja
az aktort. A környezet egy \textit{elosztott könyvtár} segítségével tartja nyilván
az aktorok összes aktivációját a rendszerben. A könyvtárban vagy egy létezõ aktivációt
talál, vagy kiválaszt egy szervert, és létrehoz egy új aktivációt. Az üzenetküldés 
ezután szerializálja az üzenetet, és a nyitott TCP kapcsolaton keresztül továbbítja 
a célszervernek. A célszerver üzenetküldés alrendszer deszerializálja az üzenetet,
és átadja a végrehajtásnak, mely ezután ütemezi a hívást. Ha egy aktor éppen egy
másik hívást dolgoz fel, az üzenet sorban áll addig, amíg a feldolgozás be nem fejezõdik.

%TODO Add figure
%\begin{figure}[ht!]
%	\centering
%	\includegraphics[width=90mm]{figures/}
%	\caption{
%	\label{fig:}}
%\end{figure}

A környezet felel a lokális erõforrások kezeléséért is. Ha egy aktorra egy bizonyos
(elõre definiált) ideje nem volt szükség, vagy ha a szerver erõforráshiányt észlel,
a környezet automatikusan deaktiválja az aktort, és visszaveszi az erõforrásait.

\subsubsection{Izoláció}
Az Orleans aktorok nem osztanak meg memóriát és izoláltak egymástól.
Az aszinkron üzenetküldés az egyedüli kommunikációs mód köztük, amelyek
metódusok formájában jelennek meg az aktorok interfészén. Ezen felül a metódushívások
paraméterei és visszatérési értékei a hívás során lemásolódnak (még akkor is,
ha a metódushívás két ugyanazon a szerveren lévõ aktor között megy végbe),
ezzel biztosítva hogy az elküldött üzenet ne módosulhasson.

\subsubsection{Kooperatív multitasking}
Az Orleans az egyes fordulókat \textit{kooperatív multitasking} formában ütemezi. Ez azt jelenti, hogy
egy alkalmazás forduló az elindítása után megszakítás nélkül végrehajtódik. Az Orleans ütemezõje
az aktorok futtatásához és ütemezéséhez tipikusan annyi számítási szálat használ, 
amennyi processzormaggal rendelkezik az adott rendszer. 

Egy komplex rendszerben az aktor aktivációk száma akár milliós nagyságrendû is lehet. 
\textit{Preemptív multitasking} használata esetén az összes aktiváció saját szálat kapna, ez pedig egy bizonyos
számú aktiváció felett több lenne, mint amit a rendszerek képesek kezelni, ráadásul a kontextusváltás
drága, így ez is rontana a teljesítményen.

\subsubsection{Megbízhatóság}
A rendszer a megbízhatóság összes aspektusát automatikusan kezeli, kivéve az aktorok perzisztens állapotának
menedzselését. A rendszer automatikusan menedzseli a klaszterben lévõ szervereket. Az egyes szerverek
\textit{ping} üzeneteket küldenek egymásnak, és ha egy bizonyos szervertõl több másik szerver sem kap választ,
akkor a szervert leálltnak tekintik.

Ha egy szerver leállt, az összes rajta futó aktiváció elveszik. Ekkor a többi szervernek ezekre az aktivációkra
vonatkozó információkat ki kell törölniük a rendszer elosztott könyvtárából. 
Mivel az aktorok virtuálisak, egy aktor nem áll le ha az õt futtató szerver leáll.
Ehelyett a következõ üzenet, amelyet a leállt szerveren lévõ aktornak küldenek, egy új aktivációt fog létrehozni
egy másik, élõ szerveren. 

Egy aktor állapotának mentési stratégiája nagymértékben függ az aktor feladatától. Ha például
az aktorunk egy eszközt (\textit{mobiltelefon}, \textit{szenzor}) reprezentál, melyet az eszköz az adataival
periodikusan frissít, akkor nem szükséges elmentenünk az aktor állapotát, mivel az új aktiváció a következõ
frissítéssel küldött adatokból képes lesz azt elõállítani.
Ha nem engedhetünk meg állapotvesztést, akkor a mentés minden üzenet feldolgozása után szükséges, 
vagy megengedõbb esetben, megadott idõközönként esedékes a mentés.

Tekintve, hogy egy aktor (és az egész rendszer) teljesítményét nagymértékben befolyásolhatja, és minden aktorra
különbözhet a mentési stratégia, a rendszer nem kezeli az állapotok automatikus mentését, ezt a fejlesztõkre bízza. 

\subsubsection{Aktorok elhelyezése}
Az Orleans rendszer futása során automatikusan és transzparensen hozza létre az aktorokat.
Ez azt jelenti hogy nem szolgáltat információt azok fizikai elhelyezkedésérõl, 
tehát arról, hogy a létrehozott \textit{Grain} aktiváció melyik szerveren helyezkedik el a klaszterben.
Az aktorok elhelyezését direkt módon nem vezérelhetjük, azonban a \textit{Placement} attribútumok
használatával egy \textit{Grain} osztályon, közvetetten befolyásolhatjuk, hová "szeretnénk", 
hogy az új aktiváció kerüljön. 

Az Orleans jelenleg 3 fajta elhelyezési (\textit{Placement})
stratégiát támogat: 
\textit{Aktivációk száma alapján} történõ elhelyezés (\textit{ActivationCountBasedPlacement}), 
\textit{Lokális} elhelyezés (\textit{LocalPlacement}), 
valamint \textit{véletlenszerû} elhelyezés (\textit{RandomPlacement}). A véletlenszerû elhelyezés 
használatával az összes szerverre egyenlõ valószínûséggel kerül az új aktiváció. Lokális elhelyezés
során az aktivációt kérõ \textit{Grain} szerverére történik az elhelyezés. Ha az aktiváló nem egy 
\textit{Grain}, hanem a kliens volt, ennek az elhelyezési stratégiának nincs hatása, és a 
\textit{RandomPlacement} stratégia alapján kerül az új aktiváció elhelyezésre. Az aktivációk száma alapján
történõ elhelyezés a legkevesebb aktivációval rendelkezõ szerverre helyezi el a 
kért \textit{Grain} aktivációt.

\subsection{Orleans projektek felépítése} \label{subs:orleansProjects}
Egy Orleans alkalmazást 3 fõ komponens épít fel: \textit{Aktorok} (\textit{Grains}), 
\textit{Aktor interfészek} (\textit{Grain Interfaces}) valamint a \textit{Kliens} (\textit{Client}). Ezek a komponensek 
különálló alprojektekként jelennek meg a rendszerben.

A \textit{Grain interfaces} komponensben definiálhatjuk a projektben használt aktorokat, 
valamint ezek metódusait és a metódusok szignatúráját. Csak az itt definiált aktor típusok lesznek késõbb
felhasználhatóak, melyek implementációját a \textit{Grains} komponens tartalmazza.

A \textit{Client} komponens köti össze a külvilágot a rendszerrel, tulajdonképp egy belépési pont
az Orleans környezetbe. A kliens rendelkezhet \textit{Grain} referenciákkal, 
valamint üzenetet is küldhet \textit{Grain}-eknek. A megfelelõ kommunikáció érdekében a \textit{Client}
illetve a \textit{Grains} komponensnek is rendelkeznie kell ugyanazzal a \textit{Grain Interfaces} komponenssel.


\subsection{Alkalmazási lehetõségek} %TODO Not the best section title.
Az Orleans környezet alapvetõen a \textit{Szolgáltatás-orientált architektúra} jegyében épült alkalmazások fejlesztését
támogatja - egymástól teljesen izolált, önálló szervizek összessége, melyek jól skálázódnak, és egy meghatározott 
mûvelet elvégzésére képesek. Egy komplex alkalmazás több száz, vagy akár több ezer szervizbõl is állhat, és a szervizek
száma az alkalmazás terheltségének változásával dinamikusan nõhet, illetve csökkenhet.
A szervizek tipikusan nem komplex, mûveletigényes számítások elvégzésére alkalmasak, fõ szempont a reszponzivitás. 

Ennek megfelelõen az Orleans aktorok egymástól izolált egységek, melyek nem osztanak meg memóriát egymással,
az egyedüli kommunikációs lehetõség közöttük az aszinkron üzenetküldés. Egy számítási szállal rendelkeznek, és 
alapértelmezés szerint az aktor entitás egyszerre csak egy üzenetet dolgozhat fel, a többi beérkezõ üzenet blokkolódik.
Mivel az aktorok virtuálisak, így a futtatókörnyezet az skálázást a terhelésnek és a rendelkezésre álló 
erõforrásoknak megfelelõen alakíthatja.

\subsubsection{Térinformatikai alkalmazás}
A dolgozat által vizsgált feladat számos ponton különbözik a fent felsorolt szempontoktól - távérzékelt adatok
feldolgozásához gyakran hatalmas méretû adatokkal kell dolgoznunk, a mûveletek költségesek, és akár több 
órát is igénybe vehetnek, valamint a mûveletek legtöbbjének párhuzamosítása esetén az egyes folyamatoknak más
folyamatok adataihoz is hozzá kell férniük. A dolgozat része volt ezen szempontbéli különbségek kiküszöbölése
a megfelelõ eredmény érdekében - a késõbbi fejezetekben az alkalmazott megoldások és az eredmények
részletesen is tárgyalásra kerülnek.

Az Orleans térinformatikai kiegészítéséhez szükséges volt egy olyan keretrendszer integrációja és felhasználása,
amelynek segítségével egységesen kezelhetünk és dolgozhatunk fel téradatokat. Így esett a választás az \textit{AEGIS}
keretrendszerre, mely a következõ fejezetben kerül tárgyalásra.

% ------------------------------------------------------------------------------

\chapter{Az AEGIS térinformatikai keretrendszer}
Az \textit{AEGIS} keretrendszer \textit{Eötvös Loránd Tudományegyetem Informatikai Karán} jelenleg is fejlesztés alatt
álló térinformatikai keretrendszer, melynek fõ célja térinformatikai algoritmusok, megoldások \textit{kutatás}a és \textit{fejlesztés}e.
A rendszer téradatok széles spektrumát támogatja, például: \textit{vektoros adathalmazok}, \textit{raszter felvételek}
valamint \textit{pontfelhõk}. A rendszer egy platformfüggetlen osztálykönyvtár, melynek fejlesztése C\# nyelven
történik, alapja a \textit{.NET keretrendszer}, illetve a \textit{Mono Framework}. A fejlesztés a komponens alapú
architektúra jegyében történik, mely lehetõséget ad a rendszer bõvítésére, valamint az újrafelhasználhatóságra.
Ennek segítségével az egyes komponensek könnyedén integrálhatóak más alkalmazásokba\cite{aegis}.
Mindezek mellett az AEGIS keretrendszer rendelkezik azokkal a távérzékelt adatfeldolgozó
mûveletekkel, amelyek a dolgozatban kutatásra kerültek. Ezek alapján a rendszer megfelelõ környezetet
biztosított az Orleans térinformatikai kiegészítésére.

Az AEGIS keretrendszert felépítõ fõbb komponensek: \textit{Core, IO, Operations, Temporal}.
A \textit{Core} komponens a rendszer adatmodellével kapcsolatos osztályokat tartalmazza, az \textit{IO} 
téradatok betöltéséért és írásáért felel (pl.: \textit{Shapefile} vagy \textit{GeoTIFF} formában),  %TODO cite Shapefile and tiff?
az \textit{Operations} komponens tartalmazza a téradatokon végezhetõ mûveleteket, valamint ezek futtatókörnyezetét,
a \textit{Temporal} komponens pedig az adatmodell kiterjesztése idõbeliség kezelésével.

%\begin{figure}[ht!]
%	\centering
%	\includegraphics[width=90mm]{figures/aegis_components.jpg}
%	\caption{Az \textit{AEGIS} rendszer komponensei
%	\label{fig:aegis_components}}
%\end{figure}

\section{Adat-, illetve mûveleti modell}
A rendszer adatmodellje az \textit{Open Geospatial Consortium (OGC)} szervezet által definiált
\textit{Simple Feature Access (SFA)}\cite{sfa} szabvány. A szabványban a központi geometriai 
primitív a \textit{Geometry} osztály, mely a térbeli tulajdonságokat, és az egyes térbeli objektumok 
között elvégezhetõ mûveleteket definiálja. Az adatmodell két-, illetve háromdimenziós vektoros 
adatok tárolására koncentrál, idõbeliség nélkül. Az egyes mûveletek egységes alkalmazhatósága érdekében
az implementáció során a szabvány kiterjesztésre került raszteres adatok támogatásával is, így a 
\textit{Raster} osztály a \textit{Geometry} leszármazottja.

\begin{figure}[h!]
	\centering
	\captionsetup{width=0.9\textwidth, justification=centering}
	\includegraphics[width=120mm]{figures/aegis_data_model_extensions.png}
	\caption{Az \textit{AEGIS} adatmodellje és kiterjesztése raszteres támogatással
		\label{fig:aegis_data_model}}
\end{figure}
 
Az \textit{Operations} komponensben implementált algoritmusok kezelése is egységes alapon történik, minden mûvelet
közös õse az absztrakt \textit{Operation} osztály. A mûveletek rendelkeznek egy leíró osztállyal is (\textit{OperationMethod})
rendelkeznek, melynek segítségével kategorizálhatjuk a metódusokat, valamint optimalizálhatjuk a végrehajtást.
A mûveletek paramétereinek objektuma az \textit{OperationMethodParameter}, amely tartalmazza a paraméter típusát,
valamint értékét (\ref{fig:aegis_operations}. Ábra).

A mûveletet az Operation osztály \textit{Execute()} metódusával futtathatjuk. Az \textit{Execute()} metódus
futása során rendre három alfüggvényt hív meg, ezek: \textit{PrepareResult(), ComputeResult(), FinalizeResult()}.
A \textit{PrepareResult()} a számításokhoz elõállítja a kiinduló adathalmazt, a \textit{ComputeResult()} a tényleges 
számításokat hajtja végre, a \textit{FinalizeResult()} metódus pedig összegzi és véglegesíti az eredményt.
A leszármazott osztályok ezen metódusok felüldefiniálásával határozhatják meg a mûvelet mûködését.

\begin{figure}[h!]
	\centering
	\includegraphics[width=150mm]{figures/aegis_processing.png}
	\caption{Az \textit{AEGIS} mûveleti modellje
		\label{fig:aegis_operations}}
\end{figure}

Minden térbeli mûvelet, amely vektoros
adatokra definiált (\textit{metszet, projekció}), alkalmazható raszteres felvételekre is.
A csak raszteres adatokon futó mûveleteket (\textit{szûrés, küszöbölés, hisztogram-transzformáció})
pedig olyan metaadattal látjuk el, amely megakadályozza a vektoros adathalmazon történõ futtatást.
Ezek a raszteres mûveletek az \textit{Operations} komponens \textit{Spectral} kiterjesztésében
helyezkednek el. A dolgozat során az itt implementált mûveletek kerültek felhasználásra.

%TODO Can we place a package diagram here?

\section{Feldolgozás Hadoop architektúrán}
Az AEGIS támogatja a \textit{Hadoop} architektúrával történõ adatkezelést, illetve feldolgozást.
A rendszer megfelelõen kezeli nagyméretû bináris adatok \textit{HDFS}-be történõ beolvasását (pl.: \textit{GeoTIFF} formában).
Az input adat opcionálisan particionálható, az egyes partíciók így elosztottan is feldolgozhatók (A fent említett
\textit{Operations} komponensben definiált mûveletek módosítás nélkül alkalmazhatók Map-, illetve Reduce függvényekként).

A keretrendszer Hadoop támogatása jelentõsen megkönnyítette a dolgozat során vizsgált mûveletek
teljesítményének összevetését az Orleans keretrendszerrel. A Hadoop rendszerhez
nem volt szükséges külön térinformatikai keretrendszer felhasználása, így az architektúrából adódó teljesítménybeli
differenciák sem jelennek meg az eredményekben. 

% ------------------------------------------------------------------------------

\chapter{Megvalósítás}
A dolgozat célja az Orleans rendszer távérzékelt felvételek feldolgozására való kiterjesztése és
a gyakorlatban való alkalmazhatóságának vizsgálata. 
Ehhez szükséges volt egy olyan prototípus alkalmazás megvalósítása, 
melynek segítségével tesztelhetõek az Orleans rendszer képességei távérzékelt felvételek feldolgozásában. 
Ezen fejezet célja az alkalmazás felépítésének és komponenseinek bemutatása.

A dolgozat során elkészített prototípus alkalmazás (\textit{OrleansSpectral}) felépítése hasonló a 
tradicionális Orleans alkalmazásokhoz, rendelkezik a \ref{subs:orleansProjects}. szakaszban említett
3 komponenssel (\textit{Grains}, \textit{Grain interfaces}, \textit{Client}), valamint ezeken túl 
egy \textit{Common} projekttel, amely az egyes komponensek mindegyike
által használt osztályokat és mûveleteket tartalmazza.

\begin{figure}[ht!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=130mm]{figures/orleansSpectralComponents.png}
	\caption{Az alkalmazás komponensdiagramja \label{fig:orleansSpectralComponents}}
\end{figure}

\section{Az AEGIS keretrendszer integrációja}
Távérzékelt felvételek feldolgozásához szükség volt egy egységes téradatmodellre,
a felvételek beolvasására, a végrehajtandó mûveletekre, illetve az eredmények lemezre történõ kiírására.
Ennek megfelelõen az \textit{AEGIS} keretrendszer \textit{Core, IO}, valamint \textit{Operations} komponenseire volt
szükség, ezek kerültek integrálásra. Mivel mindkét rendszer a \textit{.NET} keretrendszerre épül, 
így az integráció is egyszerû volt, csupán az AEGIS által nyújtott \textit{.NET szerelvények} 
(\textit{assembly}) referálására volt szükség a fent felsorolt projektekben.

\section{Input adatok particionálása és feltöltése} %TODO Not the best section title
A \ref{ch:remoteSensingAnalysis}. fejezetben említésre került, hogy távérzékelt felvételek
elosztott feldolgozásánál az input adatokat valamilyen tulajdonság alapján feldarabolunk
és az egyes darabokat külön számítási egységekkel dolgozunk fel. Az Orleans rendszer
esetén is ez történt, azonban a particionálás mûvelete kiegészült egy 
\textit{partíció leíró} fájl generálásával, amely tartalmazza az eredeti kép dimenzióit,
az egyes darabok elhelyezkedését és kiterjedését az eredeti képhez képest, a fájlok fizikai elérési útvonalát,
valamint további metainformációkat (pl: a particionáláshoz használt algoritmus). 
Ezen felül a leíró fájl tartalmazza az 
eredeti kép \textit{hisztogram-értékei}t, ez az információ késõbb felhasználható az egyes mûveletekben.
A leíró fájl segítségével könnyedén meghatározható, hogy a kép egy darabja hol foglal helyet az eredeti képen.

\begin{figure}[h!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=150mm]{figures/partitionDescriptor.png}
	\caption{Az input egy lehetséges particionálása és a partíció leíró fájl \label{fig:partitionDescriptor}}
\end{figure}


Mivel a Hadoop \textit{HDFS} rendszerrel ellentétben az Orleans keretrendszer nem definiál saját elosztott
fájlrendszert, így a feldarabolt kép darabjainak szétosztása manuálisan történik a klaszterben. Az egyes darabokat
fel kell töltenünk a feldolgozó egységekre, és az elérési útvonalukat 
rögzítenünk kell a partíció-leíróba.

\subsection{Adatok feltérképezése, azonosítása és beolvasása}
Az adatok elhelyezése után az õket feldolgozó aktorok létrehozása következik.
A megfelelõ teljesítmény érdekében minden partíciót külön aktor fog feldolgozni,
ehhez szükséges tudnunk mely szerveren hány fájlpartíció helyezkedik el, és ezek mindegyikére
létrehozni egy aktor entitást. 

Mint korábban említésre került, direkt módon nem határozhatjuk meg az aktorok elhelyezését a
klaszterben, azonban az elhelyezési stratégiát befolyásolhatjuk a \textit{Placement} attribútumokkal.
Sajnos jelenleg a rendszer nem tartalmaz olyan \textit{Placement} stratégiát, amellyel meghatározott mennyiségû
\textit{Grain}-t tudnánk létrehozni az összes szerveren (Az \textit{ActivationCountBasedPlacement} áll
legközelebb a feladathoz, azonban ez a stratégia fõként nagyobb klaszterek esetén tud hatékony lenni
a dolgozat során nem produkált használható teljesítményt).

A fenti limitációk megkerülése érdekében egy saját stratégia került alkalmazásra - bevezetünk egy
"\textit{manager}" aktort (\textit{OperationManagerGrain}), 
melyet a \textit{RandomPlacement} attribútummal látunk el. A \textit{manager} %TODO check if RandomPlacement is used
aktorból addig hozunk létre új aktivációkat, amíg a klaszter minden szerverén legalább egy létre nem jön
(alapértelmezés szerint az aktort hosztoló szerver identitása is transzparens az alkalmazás számára, 
azonban ez az információ a \textit{Grain}-ek identitásából visszafejthetõ).

\begin{figure}[h!]
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=110mm]{figures/getOneGrainFromEachSilo.png}
	\caption{Minden szerverrõl egy menedzser aktor aktiválása \label{fig:getOneGrainFromEachSilo}}
\end{figure}

Mivel a véletlenszerû elhelyezés közel normális eloszlású, és mivel az aktorok létrehozása nem költséges
mûvelet, így ez a fázis nem okoz teljesítményromlást a feldolgozásban. 
A létrehozott aktorok közül minden szerverrõl egyet választunk, ez lesz a szerver "menedzsere". 

A menedzser entitás nem végez spektrális mûveleteket, hanem a mûveleteket feldolgozó aktorok 
példányosításáért és a kliensnek való továbbításáért felel. Egy elõkészítési fázisban
minden menedzser \textit{Grain} feltérképezi a szerverén lévõ feldolgozandó fájldarabokat
(a partíció leíróban megadott útvonalon), és ennek megfelelõ mennyiségû feldolgozó \textit{Grain}-t
(\textit{SpectralOperationGrain}) példányosít. A \textit{SpectralOperationGrain}-t a \textit{LocalPlacement}
attribútummal látjuk el, így minden új aktiváció az õt példányosító menedzser alkalmazás szerverén
fog létrejönni. A létrehozott \textit{Grain}-eket ezután hozzárendeljük a feltérképezett fájldarabokhoz.
Így szerver szinten minden entitásról tudjuk hogy melyik fájldarabot dolgozza fel. 

\begin{figure}[H] 
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=155mm]{figures/grainsClassDiagram.png}
	\caption{\textit{Grain}ek osztálydiagramja \label{fig:grainClassDiagram}}
\end{figure}

Azonban a megfelelõ
kommunikáció érdekében minden szerveren minden Grain-nek tudnia kell az összes fájldarabról, és annak
elérhetõségérõl. Ehhez minden menedzser továbbítja a szerveren lévõ feldolgozó \textit{Grain}-ek 
identitását és a hozzá tartozó fájldarabokat a kliensnek (erre egy dedikált \textit{Grain} is definiálható
lett volna, azonban a feldolgozó aktorokkal való direkt kommunikációhoz egyébként is szükséges
továbbítani az identitásukat a kliensnek). A kliens a korábban említett partíció leíróban kiegészíti
az összes fájldarabra vonatkozó információt a feldolgozó \textit{Grain}-ek identitásával. 
Ezután elküldi a kiegészített leíró fájlt ezeknek az aktoroknak.


\begin{figure}[H] 
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=155mm]{figures/discoverParts.png}
	\caption{Input darabok feltérképezése, és a \textit{Grain}-ek informálása \label{fig:discoverParts}}
\end{figure}



\section{Mûveletek futtatása}
A mûveleteket végzõ aktorok létrehozása és megfelelõ információval való ellátása után következik a 
kívánt mûvelet végrehajtása. A mûveletek indítása már nem a menedzser \textit{Grain}-en keresztül történik, a kliens
direkt módon a feldolgozó \textit{Grain}-ekkel kommunikál. A mûveletet valamint paramétereit az alkalmazás indításánál
paraméterekként adhatjuk meg, ezeket az információkat kapja meg a \textit{ComputeOperation} mûvelet.
A \textit{FinalizeOperation} mûvelet felel az eredmények lemezre történõ kiírásáért, és csak akkor hajtódik végre,
ha mindegyik \textit{Grain}-en befejezõdött a ComputeOperation. Ez azért szükséges, mert egy \textit{Grain} hamarabb
végezhet mint a többi, azonban az általa tárolt adatokra szüksége lehet a többi \textit{Grain}-nek. A mûvelet futtatásának
eredményét a \textit{GetOperationResult} metódussal kérdezhetjük le az egyes \textit{Grain}-ektõl. A visszaadott
információ tartalmazza a mûvelet \textit{eredmény}ét (\textit{Futtatásra kész, Fut, Sikeres, Hibás}), 
a futás alatt \textit{eltelt idõ}t, valamint - ha a futás során hiba történt - a fellépõ \textit{kivétel}t.


\chapter{Vizsgált algoritmusok}
Az Orleans felépítésének és kiterjesztésének bemutatása után a dolgozat során vizsgált algoritmusok
ismertetése következik. Az elemzett mûveletek megválasztásánál fontos szempont volt a sokszínûség - 
a távérzékelt felvételek feldolgozásának mindkét fázisából (tehát az elõfeldolgozás és a tematikus 
osztályozás fázisból), mindegyik munkaterület-csoportból kerültek kiválasztásra
mûveletek, ezáltal átfogó képet kaphatunk, a képfeldolgozás mely részein alkalmazható hatékonyan a rendszer.

Az egyes mûveletek Orleans kiterjesztése munkaterület-csoportonként különbözõ megközelítést igényelt,
így a bemutatás az egyes csoportokon végighaladva történik, ismertetve a mûveletek mellett az alkalmazott
ötleteket, és megvalósításukat.


\section{Lokális mûveletek}
%TODO Recompose
Elosztott feldolgozás szempontjából a legegyszerûbb munkaterület-csoport a lokális mûveletek csoportja.
Ebben az esetben az input kép tetszõleges módon particionálható, és elosztottan feldolgozható, nem szükségesek
további lépések. A lokális mûveletek egyszerûségük miatt megfelelõ alapot nyújtottak a vizsgált rendszer alapvetõ
lehetõségeinek megismerésére, melyre a késõbbiekben építkezni lehetett. Ezen felül a lokális mûveletek segítségével
a rendszer egyes számítási egységeinek teljesítménye is mérhetõ volt, így tesztelésre kerültek kevésbé számításigényes
(pl.: \textit{Spektrális invertálás}), valamint bonyolultabb mûveletek (pl.: \textit{ToA-Reflektancia}).

\subsubsection{Spektrális Invertálás}
A \textit{spektrális invertálás} egy egyszerû lokális \textit{látványjavító mûvelet}, melynek során az egyes 
intenzitásértékeket "megfordítjuk" a felvétel minden egyes képpontjának minden sávjára. 
Ezt úgy érhetjük el, hogy a radiometriai felbontás maximálisan felvehetõ értékébõl kivonjuk az intenzitásértékeket.
A \ref{subs:remoteSensingBasics}. szakaszban bemutatott jelölést felhasználva a mûvelet
matematikailag a következõképpen ábrázolható: Egy \textit{N} sorból és \textit{M} oszlopból álló, 
\textit{B} spektrális sávval rendelkezõ \textit{V} digitális felvételbõl az 
alábbi \textit{V'} digitális felvétel áll elõ:

\begin{center}
	$
	V' = 
	\begin{pmatrix}
	\vec{v'}_{11} & \cdots & \vec{v'}_{1\textit{M}} \\
	\vdots  & \ddots & \vdots  \\
	\vec{v'}_{\textit{N}1} & \cdots & \vec{v'}_{\textit{NM}} 
	\end{pmatrix}
	$,
\end{center}
\begin{center}
melynek minden $b \in [1\hdots B]$ spektrális sávjára:
\end{center}
\begin{center}
$v'_{\textit{ijb}} = H - v_{\textit{ijb}}$,
\end{center}
ahol \textit{H} a \textit{V} vektor radiometriai felbontásának maximálisan ábrázolható értéke.

%egyes elemeinek intenzitásvektora: 
%$\vec{v}_{\textit{ij}} = (v_{\textit{ij}1}, \hdots, v_{\textit{ijB}})$, ahol minden $b \in [1\hdots B]$ elemre
%$v_{\textit{ijb}} \in [\textit{1}\hdots\textit{H}]$.
%$v'_{\textit{ijb}} = H - v_{\textit{ijb}}$.

\subsubsection{ToA-Reflektancia}
A \ref{ssn:preProcessing}. szakaszban ismertetett \textit{ToA-Reflektancia} a \textit{radiometriai korrekció}k 
közé tartozó lokális
mûvelet, melynek célja a földfelszín tényleges sugárzásának megállapítása a légköri zavaró hatások figyelembe vétele nélkül.
A ToA-Reflektancia kiszámítása függ a felvételt készítõ eszköztõl, az eszköz geometriai pozíciójától és a felvételezés
idõpontjától. Ezeket az információkat általában a feldolgozni kívánt felvétel \textit{metaadatokként} tartalmazza.
Az elosztott feldolgozás során az input adatok partícionálásánál kell arra ügyelni, 
hogy a metaadatok az egyes partíciókba is bekerüljenek.

\subsubsection{Konstans küszöbölés}
A \textit{konstans küszöbölés} a küszöbölõ algoritmusok legegyszerûbb formája. Egy darab spektrális sávot tartalmazó
képre elvégezve
a küszöbölés eredménye egy olyan bináris kép, ahol az egyes képpontok két kategóriába tartozhatnak.
Azt, hogy melyik kategória felel meg egy adott képpontnak, az alapján határozzuk meg, 
hogy intenzitása alacsonyabb vagy magasabb a megadott \textit{konstans küszöb}értéknél. A szokásos jelöléssel egy
\textit{N} sorból és \textit{M} oszlopból álló \textit{V} mátrixra és egy \textit{K} konstans küszöbértékre 
alkalmazott küszöbölés eredménye egy 

\begin{center}
	$
	V' = 
	\begin{pmatrix}
	v'_{11} & \cdots & v'_{1\textit{M}} \\
	\vdots  & \ddots & \vdots  \\
	v'_{\textit{N}1} & \cdots & v'_{\textit{NM}} 
	\end{pmatrix}
	$,
\end{center}
\begin{center}
mátrix, melynek minden $v'_{ij}$ elemére $v'_{ij} \in \mathbb{L}$ és
\end{center}
\begin{center}
	$
	v'_{ij} = 
	\begin{cases}
		1 & \quad \text{ha } v'_{ij} \geq K	 \\
		0 & \quad \text{ha } v'_{ij} < K \\
	\end{cases}
	$
\end{center}

%TODO Do we need this section here? If so, consider writing about Orleans as well.
%\subsubsection{Lokális mûveletek MapReduce alapú feldolgozása}
%A fent felsorolt mûveletek MapReduce módon történõ feldolgozása hasonlóan egyszerû feladat 
%- az input tetszõleges módon particionálható, és a mûveletek elvégezhetõek egy szimpla \textit{Map} fázisban. 

\section{Fokális mûveletek}
\textit{Fokális mûveletek} végrehajtása esetén egy pixel kiszámításához szükség van a pixel egy
meghatározott sugarú környezetének értékeire. A szükséges terület méretét a mûvelet elindításának
pillanatában ismerjük, és a futás során ez az információ nem változik.
%TODO Consider moving this into new section
Fokális mûveletek esetén két lehetõségünk van: vagy már a particionálás során figyelembe vesszük,
hogy várhatóan mekkora területre lesz szüksége az egyes mûveleteknek és ez alapján a partíciókat
\textit{átfedések}kel hozzuk létre - ekkor a mûvelet indításakor biztosítanunk kell, hogy a
mûvelet által igényelt terület méreténél nagyobb, vagy egyenlõ a felhasznált partícióra definiált átfedés.

Egy másik lehetõség ha a partíciók nem rendelkeznek átfedésekkel,
hogy a feldolgozás során a szükséges intenzitásértékeket a feldolgozó egységek egymás
számára elérhetõvé teszik. Ekkor ha egy egységnek egy olyan értékre van szüksége,
amelyet egy másik feldolgozó egység birtokol, akkor ezt az értéket futás során "elkérheti"
a birtokló folyamattól.
Ezzel a megoldással valószínûleg nem érhetõ el olyan teljesítmény, mint
ha az összes adat lokálisan rendelkezésre állna, cserébe viszont a partíciók mérete nem nõ.
További finomítási mód lehet például, ha a folyamatok egyszerre nem csak egy-egy koordináta 
intenzitás-értékeit kérik el, hanem meghatározott méretû blokkokat. Ebben az esetben csökken a
hálózati kommunikációk száma, azonban növekszik a hálózaton átküldött adatok mérete.

\subsection{Szûrések}
A fokális mûveletekre talán a legjobb példa a különbözõ \textit{szûrések} alkalmazása. Szûréseket a képfeldolgozás
számos területén alkalmazhatunk, például: \textit{éldetektálás, simítás, elmosás, élesítés}. A szûrõ mûveletek
során az eredmény pixelértékét a kép minden egyes pixelére az õt valamilyen sugárban körülvevõ értékek súlyozott átlaga adja.
Az egyes súlyokat legtöbbször egy \textit{kernelmátrix}  segítségével definiáljuk - ezzel megadható, hogy a környezet 
pixelei milyen módon számítanak bele az eredménybe. Például az inputkép minden pixelét változatlanul hagyó szûrõ
kernelmátrixa az alábbi:
\begin{center}
	$
	\begin{bmatrix}
	0 \quad 0 \quad 0 \\
	0 \quad 1 \quad 0 \\
	0 \quad 0 \quad 0 \\
	\end{bmatrix}
	$
\end{center}

A kernelmátrix középsõ értéke az aktuális pixel-, a többi értéke pedig az õt körülvevõ pixelek súlya.

\subsubsection{Átlagoló szûrõ}
Az \textit{átlagoló szûrõ (box filter)} egy egyszerû lineáris szûrõ, amelynek eredményeként minden pixel értéke az 
õt meghatározott sugárban körülvevõ input pixelek értékének súlyozatlan átlaga, tehát a kernelmátrixa a következõképpen
írható fel: 

\begin{center}
	$
	\begin{bmatrix}
	1 \quad 1 \quad 1 \\
	1 \quad 1 \quad 1 \\
	1 \quad 1 \quad 1 \\
	\end{bmatrix}
	$
\end{center}

Az átlagoló szûrõ használatával elérhetjük a kép simítását, valamint
egy bizonyos számú iterációban egymás után alkalmazva közelíti a \textit{Gauss szûrõ}t.

\subsubsection{Gauss szûrõ}
A \textit{Gauss szûrõ (Gaussian blur)} egy széles körben használt szûrõ a grafikus képfeldolgozás 
területén, legfõképp a kép zajosságának csökkentésére és a részletesség redukálására használatos.
A Gauss szûrõ alkalmazása során a képet egy \textit{Gauss függvény} segítségével
mossuk el, tehát a szûrõ kernelmátrixában egy kétdimenziós \textit{Gauss-eloszlás} értékei szerepelnek\cite{gaussianBlur}.
Egy $0$ várható értékû, $\sigma$ szórású Gauss-eloszlás a következõképpen írható fel:

\begin{center}
$
		G(x, y) = {1 \over \sqrt{2\pi\sigma^2}}
		e^{-{x^2 + y^2 \over 2\sigma^2}}
$
\end{center}

A kernelmátrixot a fenti Gauss-eloszlás segítségével állíthatjuk elõ, ekkor az $x$ és az $y$ értékek a kernelmátrix
középpontjától számított távolságok a horizontális-, illetve a vertikális tengely mentén. 

\subsubsection{Gabor szûrõ}
A \textit{Gábor Dénes} után elnevezett \textit{Gabor szûrõ (Gabor filter)} egy lineáris szûrõ, 
mely a korábban bevezetett Gauss függvény modulálása egy síkbeli szinuszhullámmal. A képfeldolgozásban legtöbbször
írott és nyomtatott szöveg felismerésére, arcfelismerésre, valamint éldetektálásra használatos.\cite{gaborFilter2}

\subsection{Fokális mûveletek feldolgozása az Orleans rendszerben}
A fokális mûveletek elosztott feldolgozása során az egyes partíciók legtöbbször meghatározott mennyiségû plusz 
adatot igényelnek
szomszédaiktól. Ez a legtöbbször megoldható a korábban ismertetett átfedések definiálásával, mivel
a mûveletek futtatásánál ellenõrizni tudjuk, hogy elegendõ plusz terület áll-e rendelkezésre a végrehajtáshoz.
A Hadoop alapú feldolgozás ezt a megoldást használja, és az Orleans rendszer is felkészült a plusz területtel rendelkezõ
adatok feldolgozására, azonban a \textit{Grain}-ek egymás közti \textit{direkt kommunikáció}ján alapuló feldolgozás is
implementálásra került annak érdekében, hogy megfelelõ képet kaphassunk, a kétfajta megközelítés közül melyik elõnyösebb
a távérzékelt felvételek feldolgozása kapcsán.

\subsubsection{Virtuális Raszter}
Az AEGIS rendszerben megvalósított metódusok jelenleg egy konkrét raszter kép minden pixelét feldolgozzák, nincs lehetõség
annak meghatározására, hogy mûvelet a kép csak egy részterületén dolgozzon. Emiatt ha a képet átfedés nélkül 
feldaraboljuk és az eredeti mûveleteket végrehajtjuk, az egyes partíciók szélén nem fognak helyes eredményt adni,
mivel a mûveletnek nincs információja, hogy az adott partíció egy nagyobb kép része és a szélén lévõ pixelek kiszámításához
szükséges lehet további adat felhasználása is.

A fenti probléma kétféleképpen volt orvosolható. Az egyik lehetõség a mûveletek teljes újraírása és adaptálása
az Orleans környezetbe, így a módosított mûveletek a partíció abszolút pozíciója alapján futottak volna, és a 
szükséges helyeken (a partíciók szélein) kezelték volna az esetleges \textit{Grain} kommunikációt, ezáltal a szükséges
plusz adatok beszerzését. Azonban ez a megoldás több szempontból is kedvezõtlen volt. Egyrészt az összes
mûvelet módosítása már önmagában is jelentõs ráfordítással járt volna és így a keretrendszer által 
nyújtott elõnyök nagy része nem lett volna felhasználható. Másrészt a jövõben implementálásra kerülõ mûveletek 
adaptációja is elkerülhetetlen lett volna.

Az AEGIS keretrendszer fejlesztésekor azonban fontos szempont volt a rugalmasság és a bõvíthetõség. 
Ennek megfelelõen minimális beavatkozással az AEGIS keretrendszerbe és mûveleteibe, lehetõség volt
a modell kiterjesztésére és ez által a fenti probléma megfelelõ kezelésére. Ehhez bevezetésre került egy 
\textit{virtuális raszter} osztály (\textit{VirtualRaster}), amely az eredeti kép dimenzióival rendelkezik, 
és egy \textit{szerviz}en keresztül éri el az egyes adatokat. A szerviz (\textit{OrleansRasterService}) 
inputja az aktuálisan feldolgozandó képdarab, a darabok azonosítására szolgáló \textit{partíció leíró}, 
valamint a feldolgozásban részt vevõ összes \textit{Grain} elérési adatai. 

A mûveletek kizárólag a szervizen keresztül férnek hozzá a raszter adatokhoz, és az eredeti kép abszolút
koordinátáival dolgoznak. Így ha a mûveletnek szüksége van egy pixelértékre, a szerviz a rendelkezésre álló
partíció leíró alapján el tudja dönteni, hogy a szükséges érték lokálisan rendelkezésre áll-e,
vagy távoli elérés szükséges hozzá. Ha lokálisan rendelkezésre áll, a szerviz 
úgyszintén a \textit{partíció leíró} alapján az \textit{abszolút} koordinátákat 
a lokális partíció \textit{relatív} koordinátáivá konvertálja, és a relatív pozíción szereplõ adatot
szolgáltatja a mûveletnek. Ellenkezõ esetben szükséges megkeresni azt a Grain-t, amely a koordinátát
tartalmazó partíciót dolgozza fel, és egy aszinkron üzenetben elkérni a szükséges adatot. 
Ezzel a megoldással bármelyik Grain entitás által végrehajtott mûvelet képes hozzáférni az input kép bármely pixelértékéhez.

\begin{figure}[H] 
	\centering
	\captionsetup{width=0.8\textwidth, justification=centering}
	\includegraphics[width=100mm]{figures/virtualRaster.png}
	\caption{A virtuális raszter felépítése és mûködése \label{fig:virtualRaster}}
\end{figure}

Ahhoz hogy a lokális adatokhoz más Grain-ek is hozzáférjenek, A Grain interfészén biztosítanunk kell a megfelelõ metódusokat.
Ezeket a metódusokat (\mbox{\textit{ReadValue}}, \mbox{\textit{ReadFloatValue}}) az \textit{IRasterProvider} interfész tartalmazza, 
ebbõl származik a feldolgozó Grain interfésze. Az Orleans ismertetésekor említésre került, hogy az egyes fordulók
alapértelmezés szerint nem fedhetik át egymást. Ez a jelenlegi esetben problémát okozna, tekintve hogy a feldolgozás során
több távoli adatra is szükség lehet és nagy valószínûséggel a távoli adattal rendelkezõ Grain is a mûveletet végrehajtó
fázisban áll. Ezért a feldolgozó \textit{SpectralOperationGrain} osztályt megjelöltük a [Reentrant] attribútummal, így a
beérkezõ kérések a mûvelet végrehajtása közben is kiszolgálásra kerülnek a Grain által.

\subsubsection{Végrehajtási terület}
Az abszolút koordináták használata miatt a mûveletek módosítás nélkül az input kép egészére futnának, nem csak a 
lokálisan elérhetõ tartalomra, ez pedig jelentõs teljesítményromláshoz vezetne. 
A probléma megoldásához az AEGIS keretrendszer minimális módosítása volt szükséges. A transzformációs mûveletek õsét, a 
\textit{SpectralTransformation} osztályt kiegészítettük egy paraméterrel, amely az adott mûvelet 
\textit{végrehajtási terület}e (\textit{Operation Area}). A végrehajtási terület definiálja azt a területet,
amelynek pixeleire szeretnénk alkalmazni a mûveletet. A mûveletnek természetesen szüksége lehet a végrehajtási területen
kívül esõ pixelekre is, ezen pixelértékeknek rendelkezésre kell állniuk a helyes eredmény érdekében. 
Az Orleans rendszerben ennek megfelelõen a mûveletek - bár az egész terület adataival rendelkeznek - 
csak a lokálisan rendelkezésre álló területen fognak végrehajtódni.

A virtuális raszter bevezetésével, valamint a mûveletek végrehajtási területtel való kiterjesztésével
megoldást adunk arra a problémára ha egy fokális mûvelet végrehajtásához
csak olyan input partíciók állnak rendelkezésre, melyek nem rendelkeznek átfedésekkel. A következõ fejezetben
a megoldás hatékonysága részletesen is tárgyalásra kerül, annyi azonban elmondható, hogy a Grain-ek hálózati kommunikációja
költséges, így a megfelelõ teljesítmény érdekében törekedni kell a kommunikációk számának minimalizálására.

%\section{Regionális mûveletek}
%\subsubsection{Negyedelõ fa alapú szegmentálás}
%\subsubsection{Szekvenciális csatolás alapú szegmentálás}
%\subsubsection{Legjobb összevonáson alapuló szegmentálás}
%\subsection{Regionális mûveletek MapReduce alapú feldolgozása}
%\subsection{Regionális mûveletek feldolgozása az Orleans rendszerben}

%\subsection{Globális mûveletek}
%\subsubsection{Kiegyensúlyozott hisztogram-küszöbölés}
%\subsubsection{Otsu küszöbölés} %TODO Is This Focal or Global method?
%https://en.wikipedia.org/wiki/Balanced_histogram_thresholding

%\subsubsection{Klaszterezés}

% ------------------------------------------------------------------------------

%\chapter{Eredmények}


% ------------------------------------------------------------------------------

%\chapter{Összegzés}

% ------------------------------------------------------------------------------


\cleardoublepage

\phantomsection
\addcontentsline{toc}{chapter}{Irodalomjegyzék}

\begin{thebibliography}{9}
\bibitem{richards} Richards, J. A., Jia, X.: \textit{Remote Sensing Digital Image Analysis, An Introduction, fifth edition}, Springer, 2013, 978-3-642-30061-5.

\bibitem{remoteSensingLecture} László, I., Csornai, G., Fekete, I., Giachetta, R.: \textit{Távérzékelt felvételek elemzése}, Egyetemi jegyzet, Eötvös Loránd Tudományegyetem Informatikai Kar, Budapest, 2014.

\bibitem{aegis} Giachetta, R.: \textit{AEGIS - A state-of-the art component based spatio- temporal framework}, OSGeo Journal 13.1, pp. 68-77, 2014.

\bibitem{aegisHadoop} Giachetta, R., Fekete, I.: \textit{A case study of advancing remote sensing image analysis}, Acta Cybernetica, 22, pp. 57-79, 2015.

\bibitem{dotnetOrleans} \textit{Microsoft Orleans, A straightforward approach to building distributed, high-scale applications in .NET}, http://dotnet.github.io/orleans

\bibitem{orleansMSR} Philip A. Bernstein, Sergey Bykov, Alan Geller, Gabriel Kliot, Jorgen Thelin: \textit{Orleans: Distributed Virtual Actors for Programmability and Scalability}, Microsoft Research

\bibitem{mapAlgebra} \textit{Map Algebra: Global, Zonal, Focal and Local Operations}, http://gisgeography.com/map-algebra-global-zonal-focal-local/

\bibitem{distributedImageProcessing} Giloi, W. Distributed Image Processing. In \textit{Advances in Digital Image Processing}, pages 249-263. 1979.

\bibitem{mapReduce} Dean, J. and Ghemawat, S. \textit{MapReduce: Simplified Data Processing on Large Clusters}. 
		In \textit{Proceedings of the 6th Conference on Symposium on Opearting Systems Design \& Implementation}, volume 6 of \textit{OSDI?04}, pages 10-10, 2004.

\bibitem{spatialHadoop} Eldawy, A. and Mokbel, M. F. \textit{SpatialHadoop: An Efficient Mapreduce Framework for Spatial Data}. Data Engineering (ICDE), 2015 IEEE 31st International Conference
					
\bibitem{hadoopGIS} Ablimit Aji , Fusheng Wang , Hoang Vo , Rubao Lee , Qiaoling Liu , Xiaodong Zhang , Joel Saltz. 
\textit{Hadoop GIS: a high performance spatial data warehousing system over mapreduce}, Proceedings of the VLDB Endowment, v.6 n.11, p.1009-1020, August 2013

\bibitem{actorOrig} Carl Hewitt, et al. \textit{Actor Induction and Meta-evaluation} Conference Record of ACM Symposium on Principles of Programming Languages, January 1974.

\bibitem{actorErlang} Vinoski, Steve. \textit{Concurrency with Erlang}. IEEE Internet Computing (2007), 11: 90-93

\bibitem{erlang} Armstrong, J. \textit{Erlang}. CACM, 53, 9 (Sept. 2010), 68-75

\bibitem{actorScala} Philipp Haller, Martin Odersky. \textit{Scala Actors: Unifying thread-based and event-based programming}, Theoretical Computer Science, v.410 n.2-3, p.202-220, February, 2009

\bibitem{actorAkka} GUPTA, Munish. \textit{Akka essentials}. Packt Publishing Ltd, 2012.

\bibitem{sfa} Herring, J. \textit{OpenGIS Implementation Standard for Geographic information-Simple feature access-Part 1: Common architecture.} OGC Document 4.21 (2011): 122-127.

\bibitem{gaussianBlur} Nixon, Mark. \textit{Feature Extraction and Image Processing.} Academic Press, 2008.

\bibitem{gaborFilter} Gabor, Dennis "\textit{Theory of communication. Part 1: The analysis of information.}" Electrical Engineers-Part III: Radio and Communication Engineering, Journal of the Institution of 93.26 (1946): 429-441.

\bibitem{gaborFilter2} FOGEL, Itzhak; SAGI, Dov. \textit{Gabor filters as texture discriminator}. Biological cybernetics, 1989, 61.2: 103-113.
\end{thebibliography}

\addcontentsline{toc}{chapter}{Ábrajegyzék}
\listoffigures

\end{document}
